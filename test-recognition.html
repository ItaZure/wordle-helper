<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wordle ËØÜÂà´ÊµãËØï</title>
    <script src='https://unpkg.com/tesseract.js@4.1.1/dist/tesseract.min.js'></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            padding: 20px;
            background: #f5f5f5;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #333;
        }
        
        .upload-area {
            background: white;
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .upload-area:hover {
            border-color: #4CAF50;
            background: #f9f9f9;
        }
        
        .upload-area.dragover {
            border-color: #4CAF50;
            background: #e8f5e9;
        }
        
        #fileInput {
            display: none;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .panel {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .panel h2 {
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        }
        
        #originalCanvas, #processedCanvas {
            max-width: 100%;
            border: 1px solid #ddd;
            display: block;
            margin: 0 auto;
        }
        
        .cells-grid {
            display: grid;
            gap: 5px;
            margin-top: 20px;
        }
        
        .cell-analysis {
            border: 1px solid #ddd;
            padding: 10px;
            background: white;
            border-radius: 4px;
        }
        
        .cell-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .cell-preview {
            width: 60px;
            height: 60px;
            border: 1px solid #ccc;
            display: inline-block;
            margin-right: 10px;
        }
        
        .cell-info {
            flex: 1;
        }
        
        .color-box {
            width: 30px;
            height: 30px;
            border: 1px solid #333;
            display: inline-block;
            margin-right: 10px;
            vertical-align: middle;
        }
        
        .state-badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            color: white;
        }
        
        .state-correct { background: #6aaa64; }
        .state-present { background: #c9b458; }
        .state-absent { background: #787c7e; }
        .state-empty { background: #d3d6da; color: #333; }
        
        .stats {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
            margin-top: 20px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .controls {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: white;
            padding: 10px;
            border-radius: 4px;
        }
        
        label {
            font-weight: bold;
            color: #555;
        }
        
        input[type="number"] {
            width: 60px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        
        button {
            padding: 8px 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        
        button:hover {
            background: #45a049;
        }
        
        .game-state {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .wordle-row {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
        }
        
        .wordle-cell {
            width: 50px;
            height: 50px;
            border: 2px solid #d3d6da;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            text-transform: uppercase;
            position: relative;
        }
        
        .wordle-cell.correct {
            background: #6aaa64;
            border-color: #6aaa64;
            color: white;
        }
        
        .wordle-cell.present {
            background: #c9b458;
            border-color: #c9b458;
            color: white;
        }
        
        .wordle-cell.absent {
            background: #787c7e;
            border-color: #787c7e;
            color: white;
        }
        
        .confidence-badge {
            position: absolute;
            bottom: -8px;
            right: -8px;
            background: #2196F3;
            color: white;
            font-size: 10px;
            padding: 2px 4px;
            border-radius: 10px;
            font-weight: normal;
        }
        
        .recognition-summary {
            margin-top: 20px;
            padding: 15px;
            background: #f0f8ff;
            border-radius: 8px;
            border: 1px solid #4CAF50;
        }
        
        .summary-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 10px;
        }
        
        .stat-card {
            text-align: center;
            padding: 10px;
            background: white;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
        
        /* OCRË∞ÉËØïÈù¢ÊùøÊ†∑Âºè */
        #ocrDebugPanel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 800px;
            background: white;
            border: 2px solid #4CAF50;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 1000;
            display: none;
        }
        
        #ocrDebugPanel.active {
            display: block;
        }
        
        .debug-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }
        
        .debug-close {
            background: #f44336;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .debug-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }
        
        .debug-stage {
            text-align: center;
        }
        
        .debug-stage h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #333;
        }
        
        .debug-canvas {
            border: 1px solid #ccc;
            background: #f9f9f9;
            max-width: 100%;
            height: 100px;
            object-fit: contain;
        }
        
        .debug-info {
            margin-top: 10px;
            font-size: 12px;
            color: #666;
        }
        
        .confidence-chart {
            margin-top: 15px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 4px;
        }
        
        .confidence-bar {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 12px;
        }
        
        .confidence-bar-label {
            width: 30px;
            font-weight: bold;
        }
        
        .confidence-bar-track {
            flex: 1;
            height: 20px;
            background: #ddd;
            border-radius: 3px;
            margin: 0 10px;
            position: relative;
            overflow: hidden;
        }
        
        .confidence-bar-fill {
            height: 100%;
            background: #4CAF50;
            transition: width 0.3s;
        }
        
        .confidence-bar-value {
            width: 50px;
            text-align: right;
        }
        
        .cell-analysis {
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .cell-analysis:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ Wordle ËØÜÂà´ÊµãËØïÂ∑•ÂÖ∑</h1>
        
        <!-- OCRË∞ÉËØïÈù¢Êùø -->
        <div id="ocrDebugPanel">
            <div class="debug-header">
                <h3>üîç OCRËØÜÂà´Ë∞ÉËØï</h3>
                <button class="debug-close" onclick="closeDebugPanel()">‚úï</button>
            </div>
            <div class="debug-content" id="debugContent">
                <!-- Âä®ÊÄÅÁîüÊàêÁöÑË∞ÉËØïÂÜÖÂÆπ -->
            </div>
            <div class="confidence-chart" id="confidenceChart">
                <!-- ÁΩÆ‰ø°Â∫¶ÂõæË°® -->
            </div>
        </div>
        
        <div class="upload-area" id="uploadArea">
            <p>üì∑ ÁÇπÂáª‰∏ä‰º†ÂõæÁâáÊàñÊãñÊãΩÂõæÁâáÂà∞ËøôÈáå</p>
            <p style="margin-top: 10px; color: #666; font-size: 14px;">ÊîØÊåÅ PNG, JPG, JPEG Ê†ºÂºè</p>
            <input type="file" id="fileInput" accept="image/*">
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>ÈÖçËâ≤ÊñπÊ°àÔºö</label>
                <select id="colorSchemeSelect" onchange="reprocess()" style="padding: 5px; border: 1px solid #ccc; border-radius: 4px; min-width: 180px;">
                    <option value="wordle2.io">wordle2.io</option>
                    <option value="lessgames.com">lessgames.com/wordless</option>
                    <option value="auto" selected>Ëá™Âä®Ê£ÄÊµã</option>
                </select>
            </div>
            <div class="control-group">
                <label>ÂàóÊï∞Ôºö</label>
                <input type="number" id="colsInput" value="5" min="3" max="11">
            </div>
            <div class="control-group">
                <label>Ë°åÊï∞Ôºö</label>
                <input type="number" id="rowsInput" value="6" min="1" max="10">
            </div>
            <div class="control-group">
                <label>Ê†ºÂ≠êÈó¥Èöô(%)Ôºö</label>
                <input type="number" id="gapInput" value="8" min="0" max="20" step="1">
            </div>
            <button onclick="reprocess()">ÈáçÊñ∞Â§ÑÁêÜ</button>
        </div>
        
        <div class="main-content">
            <div class="panel">
                <h2>üì• ÂéüÂßãÂõæÁâá</h2>
                <canvas id="originalCanvas"></canvas>
                <div id="debugInfo" style="background: #fffbf0; border: 1px solid #f0ad4e; padding: 10px; margin: 10px 0; border-radius: 4px; font-size: 12px; display: none;">
                    <strong>Ë∞ÉËØï‰ø°ÊÅØÔºö</strong>
                    <ul style="margin: 5px 0;">
                        <li>üî¥ Á∫¢Ê°ÜÔºöÊ£ÄÊµãÂà∞ÁöÑÊ∏∏ÊàèÂå∫ÂüüËæπÁïå</li>
                        <li>üîµ ËìùÊ°ÜÔºöÊØè‰∏™Ê†ºÂ≠êÁöÑËØÜÂà´Âå∫Âüü</li>
                    </ul>
                </div>
                <div class="stats">
                    <div class="stat-row">
                        <span>ÂõæÁâáÂ∞∫ÂØ∏Ôºö</span>
                        <span id="imageSize">-</span>
                    </div>
                    <div class="stat-row">
                        <span>ÂÆΩÈ´òÊØîÔºö</span>
                        <span id="aspectRatio">-</span>
                    </div>
                    <div class="stat-row">
                        <span>Ëá™Âä®Ê£ÄÊµãÂàóÊï∞Ôºö</span>
                        <span id="detectedCols">-</span>
                    </div>
                    <div class="stat-row">
                        <span>ÂΩìÂâçÈÖçËâ≤ÊñπÊ°àÔºö</span>
                        <span id="currentScheme">-</span>
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <h2>üéØ ËØÜÂà´ÁªìÊûú</h2>
                <div id="gameState" class="game-state"></div>
            </div>
        </div>
        
        <div class="panel">
            <h2>üî¨ Ê†ºÂ≠êÂàÜÊûê</h2>
            <div id="cellsAnalysis" class="cells-grid"></div>
        </div>
    </div>
    
    <script>
        let currentImage = null;
        
        // Êñá‰ª∂‰∏ä‰º†Â§ÑÁêÜ
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        
        uploadArea.addEventListener('click', () => fileInput.click());
        
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                handleFile(file);
            }
        });
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleFile(file);
            }
        });
        
        function handleFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = async () => {
                    currentImage = img;
                    await processImage(img);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        async function reprocess() {
            if (currentImage) {
                await processImage(currentImage);
            }
        }
        
        async function processImage(img) {
            const canvas = document.getElementById('originalCanvas');
            const ctx = canvas.getContext('2d');
            
            // ÊòæÁ§∫ÂéüÂõæ
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            // ÊòæÁ§∫ÂõæÁâá‰ø°ÊÅØ
            document.getElementById('imageSize').textContent = `${img.width} x ${img.height}`;
            const aspectRatio = img.width / img.height;
            document.getElementById('aspectRatio').textContent = aspectRatio.toFixed(2);
            
            // ÊòæÁ§∫ÂΩìÂâçÈÖçËâ≤ÊñπÊ°à
            const schemeSelect = document.getElementById('colorSchemeSelect');
            const scheme = schemeSelect ? schemeSelect.value : 'auto';
            document.getElementById('currentScheme').textContent = scheme;
            
            // Ëá™Âä®Ê£ÄÊµãÂàóÊï∞
            let detectedCols = 5;
            if (aspectRatio > 0.95) {
                detectedCols = Math.round(aspectRatio * 6);
                detectedCols = Math.min(Math.max(detectedCols, 5), 11);
            }
            document.getElementById('detectedCols').textContent = detectedCols;
            document.getElementById('colsInput').value = detectedCols;
            
            // ÂàÜÊûêÊ†ºÂ≠ê
            await analyzeCells(img);
        }
        
        async function analyzeCells(img) {
            const cols = parseInt(document.getElementById('colsInput').value);
            const rows = parseInt(document.getElementById('rowsInput').value);
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            // ÂÖàÊâæÂà∞Ê∏∏ÊàèÊùøÁöÑÂÆûÈôÖËæπÁïå
            const gameBounds = findGameBoard(ctx, img.width, img.height);
            console.log('Ê£ÄÊµãÂà∞ÁöÑÊ∏∏ÊàèËæπÁïå:', gameBounds);
            
            // ÊòæÁ§∫Ë∞ÉËØï‰ø°ÊÅØ
            document.getElementById('debugInfo').style.display = 'block';
            
            // Âú®ÂéüÂõæ‰∏äÁªòÂà∂ËæπÁïåÊ°ÜÔºàÁî®‰∫éË∞ÉËØïÔºâ
            const originalCanvas = document.getElementById('originalCanvas');
            const originalCtx = originalCanvas.getContext('2d');
            
            // ÈáçÊñ∞ÁªòÂà∂ÂéüÂõæ
            originalCanvas.width = img.width;
            originalCanvas.height = img.height;
            originalCtx.drawImage(img, 0, 0);
            
            // ÁªòÂà∂Ê∏∏ÊàèËæπÁïå
            originalCtx.strokeStyle = 'red';
            originalCtx.lineWidth = 2;
            originalCtx.strokeRect(gameBounds.x, gameBounds.y, gameBounds.width, gameBounds.height);
            
            // ËÆ°ÁÆóÊØè‰∏™Ê†ºÂ≠êÁöÑÂ§ßÂ∞èÔºàËÄÉËôëÊ†ºÂ≠êÈó¥ÁöÑÈó¥ÈöôÔºâ
            const cellWidth = gameBounds.width / cols;
            const cellHeight = gameBounds.height / rows;
            
            // Ëé∑ÂèñÁî®Êà∑ËÆæÁΩÆÁöÑÊ†ºÂ≠êÈó¥Èöô
            const gapRatio = parseInt(document.getElementById('gapInput').value) / 100;
            const actualCellWidth = cellWidth * (1 - gapRatio);
            const actualCellHeight = cellHeight * (1 - gapRatio);
            const gapX = cellWidth * gapRatio / 2;
            const gapY = cellHeight * gapRatio / 2;
            
            const cellsDiv = document.getElementById('cellsAnalysis');
            cellsDiv.innerHTML = '';
            cellsDiv.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            
            const gameStateDiv = document.getElementById('gameState');
            gameStateDiv.innerHTML = '';
            
            const gameRows = [];
            
            for (let row = 0; row < rows; row++) {
                const gameRow = [];
                for (let col = 0; col < cols; col++) {
                    // ËÆ°ÁÆóÊ†ºÂ≠êÁöÑÂÆûÈôÖ‰ΩçÁΩÆÔºàËÄÉËôëÈó¥ÈöôÔºâ
                    const x = gameBounds.x + col * cellWidth + gapX;
                    const y = gameBounds.y + row * cellHeight + gapY;
                    
                    // Âú®ÂéüÂõæ‰∏äÁªòÂà∂Ê†ºÂ≠êÊ°ÜÔºàÁî®‰∫éË∞ÉËØïÔºâ
                    originalCtx.strokeStyle = 'blue';
                    originalCtx.lineWidth = 1;
                    originalCtx.strokeRect(x, y, actualCellWidth, actualCellHeight);
                    
                    // Ëé∑ÂèñÊ†ºÂ≠êÂõæÂÉèÊï∞ÊçÆ
                    // Á°Æ‰øùÂùêÊ†áÂíåÂ∞∫ÂØ∏Âú®ÂõæÂÉèËåÉÂõ¥ÂÜÖ
                    const cellX = Math.max(0, Math.floor(x));
                    const cellY = Math.max(0, Math.floor(y));
                    const cellW = Math.min(Math.floor(actualCellWidth), img.width - cellX);
                    const cellH = Math.min(Math.floor(actualCellHeight), img.height - cellY);
                    const cellData = ctx.getImageData(cellX, cellY, cellW, cellH);
                    
                    // ÂàÜÊûêÊ†ºÂ≠ê
                    const analysis = analyzeCell(cellData, row, col);
                    gameRow.push(analysis);
                }
                gameRows.push(gameRow);
            }
            
            // ÂºÇÊ≠•ËØÜÂà´ÊâÄÊúâÊúâÂ≠óÊØçÁöÑÊ†ºÂ≠ê
            const ocrPromises = [];
            for (let row = 0; row < gameRows.length; row++) {
                for (let col = 0; col < gameRows[row].length; col++) {
                    const cell = gameRows[row][col];
                    if (cell.hasLetter && cell.imageData) {
                        ocrPromises.push(
                            recognizeLetter(cell.imageData).then(result => {
                                cell.letter = result.letter;
                                cell.confidence = result.confidence;
                                delete cell.imageData; // Ê∏ÖÁêÜ‰∏çÈúÄË¶ÅÁöÑÊï∞ÊçÆ
                                return cell;
                            })
                        );
                    }
                }
            }
            
            // Á≠âÂæÖÊâÄÊúâOCRÂÆåÊàê
            await Promise.all(ocrPromises);
            
            // ÂàõÂª∫UIÊòæÁ§∫
            cellsDiv.innerHTML = '';
            cellsDiv.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            
            for (let row = 0; row < gameRows.length; row++) {
                for (let col = 0; col < gameRows[row].length; col++) {
                    const analysis = gameRows[row][col];
                    const cellX = gameBounds.x + col * cellWidth + gapX;
                    const cellY = gameBounds.y + row * cellHeight + gapY;
                    const cellData = ctx.getImageData(
                        Math.max(0, Math.floor(cellX)),
                        Math.max(0, Math.floor(cellY)),
                        Math.min(Math.floor(actualCellWidth), img.width - Math.floor(cellX)),
                        Math.min(Math.floor(actualCellHeight), img.height - Math.floor(cellY))
                    );
                    const cellDiv = createCellAnalysisUI(analysis, cellData);
                    cellsDiv.appendChild(cellDiv);
                }
            }
            
            // ÊòæÁ§∫Ê∏∏ÊàèÁä∂ÊÄÅ
            displayGameState(gameRows, gameStateDiv);
        }
        
        function findGameBoard(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            // ‰ΩøÁî®Êõ¥Êô∫ËÉΩÁöÑÊñπÊ≥ïÊâæÂà∞Ê∏∏ÊàèÊùø
            // 1. ÂÖàÊâæÂà∞ÊâÄÊúâÊ†ºÂ≠êÁöÑËæπÁºò
            const edges = detectEdges(imageData);
            
            // 2. ÊâæÂà∞Ê∞¥Âπ≥ÂíåÂûÇÁõ¥Á∫øÊù°
            const horizontalLines = findHorizontalLines(edges, width, height);
            const verticalLines = findVerticalLines(edges, width, height);
            
            console.log(`ÊâæÂà∞ ${horizontalLines.length} Êù°Ê∞¥Âπ≥Á∫ø, ${verticalLines.length} Êù°ÂûÇÁõ¥Á∫ø`);
            
            // 3. Â¶ÇÊûúÊâæÂà∞‰∫ÜË∂≥Â§üÁöÑÁ∫øÊù°Ôºå‰ΩøÁî®ÂÆÉ‰ª¨Á°ÆÂÆöËæπÁïå
            if (horizontalLines.length >= 2 && verticalLines.length >= 2) {
                const minY = Math.min(...horizontalLines);
                const maxY = Math.max(...horizontalLines);
                const minX = Math.min(...verticalLines);
                const maxX = Math.max(...verticalLines);
                
                return {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            }
            
            // 4. Âê¶Âàô‰ΩøÁî®ÂéüÂßãÊñπÊ≥ïÔºàÊâæÈùûÁôΩËâ≤Âå∫ÂüüÔºâ
            let minX = width, maxX = 0;
            let minY = height, maxY = 0;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    
                    // Â¶ÇÊûú‰∏çÊòØÁôΩËâ≤ÊàñÊé•ËøëÁôΩËâ≤ÁöÑËÉåÊôØ
                    if (r < 240 || g < 240 || b < 240) {
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                    }
                }
            }
            
            // Ê∑ªÂä†‰∏Ä‰∫õËæπË∑ù
            const padding = 5;
            minX = Math.max(0, minX - padding);
            minY = Math.max(0, minY - padding);
            maxX = Math.min(width - 1, maxX + padding);
            maxY = Math.min(height - 1, maxY + padding);
            
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }
        
        // ÁÆÄÂçïÁöÑËæπÁºòÊ£ÄÊµã
        function detectEdges(imageData) {
            const { width, height, data } = imageData;
            const edges = new Uint8ClampedArray(width * height);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // ËÆ°ÁÆóÊ∞¥Âπ≥ÂíåÂûÇÁõ¥Ê¢ØÂ∫¶
                    const gx = Math.abs(data[idx] - data[idx + 4]) + 
                               Math.abs(data[idx + 1] - data[idx + 5]) + 
                               Math.abs(data[idx + 2] - data[idx + 6]);
                    
                    const gy = Math.abs(data[idx] - data[idx + width * 4]) + 
                               Math.abs(data[idx + 1] - data[idx + width * 4 + 1]) + 
                               Math.abs(data[idx + 2] - data[idx + width * 4 + 2]);
                    
                    edges[y * width + x] = (gx + gy) > 50 ? 255 : 0;
                }
            }
            
            return edges;
        }
        
        // ÊâæÊ∞¥Âπ≥Á∫ø
        function findHorizontalLines(edges, width, height) {
            const lines = [];
            const threshold = width * 0.3; // Ëá≥Â∞ë30%ÁöÑÂÆΩÂ∫¶ÊâçÁÆó‰∏ÄÊù°Á∫ø
            
            for (let y = 0; y < height; y++) {
                let count = 0;
                for (let x = 0; x < width; x++) {
                    if (edges[y * width + x] > 0) count++;
                }
                if (count > threshold) {
                    lines.push(y);
                }
            }
            
            // ÂêàÂπ∂Áõ∏ËøëÁöÑÁ∫ø
            return mergeCloseLines(lines, 10);
        }
        
        // ÊâæÂûÇÁõ¥Á∫ø
        function findVerticalLines(edges, width, height) {
            const lines = [];
            const threshold = height * 0.3; // Ëá≥Â∞ë30%ÁöÑÈ´òÂ∫¶ÊâçÁÆó‰∏ÄÊù°Á∫ø
            
            for (let x = 0; x < width; x++) {
                let count = 0;
                for (let y = 0; y < height; y++) {
                    if (edges[y * width + x] > 0) count++;
                }
                if (count > threshold) {
                    lines.push(x);
                }
            }
            
            // ÂêàÂπ∂Áõ∏ËøëÁöÑÁ∫ø
            return mergeCloseLines(lines, 10);
        }
        
        // ÂêàÂπ∂Áõ∏ËøëÁöÑÁ∫øÊù°
        function mergeCloseLines(lines, threshold) {
            if (lines.length === 0) return [];
            
            lines.sort((a, b) => a - b);
            const merged = [lines[0]];
            
            for (let i = 1; i < lines.length; i++) {
                if (lines[i] - merged[merged.length - 1] > threshold) {
                    merged.push(lines[i]);
                }
            }
            
            return merged;
        }
        
        function analyzeCell(imageData, row, col) {
            // ËÆ°ÁÆóÂπ≥ÂùáÈ¢úËâ≤
            const avgColor = getAverageColor(imageData);
            
            // ÂÖàÂàùÊ≠•ÂàÜÁ±ªÈ¢úËâ≤
            let state = classifyColor(avgColor);
            
            // Ê£ÄÊµãÊòØÂê¶ÊúâÂ≠óÊØç
            const hasLetter = detectLetterPresence(imageData);
            
            // Ê†πÊçÆÈÖçËâ≤ÊñπÊ°àÂÜ≥ÂÆöÊòØÂê¶ÈúÄË¶ÅÂ≠óÊØçÊ£ÄÊµãÊù•ÁªÜÂåñÂàÜÁ±ª
            const schemeSelect = document.getElementById('colorSchemeSelect');
            const scheme = schemeSelect ? schemeSelect.value : 'auto';
            
            if (scheme === 'auto') {
                // Ëá™Âä®Ê®°ÂºèÔºö‰ΩøÁî®Â≠óÊØçÊ£ÄÊµãÁªìÊûúÊù•ÁªÜÂåñÈ¢úËâ≤ÂàÜÁ±ª
                if (state === 'absent' || state === 'empty') {
                    if (hasLetter) {
                        state = 'absent';
                    } else {
                        state = 'empty';
                    }
                }
            } else if (COLOR_SCHEMES[scheme]) {
                // ÁâπÂÆöÈÖçËâ≤ÊñπÊ°àÊ®°ÂºèÔºöÂØπ‰∫éemptyÂíåabsentÁöÑÂå∫ÂàÜÊõ¥‰æùËµñÈ¢úËâ≤
                // ‰ΩÜ‰ªçÁÑ∂ÂèØ‰ª•Áî®Â≠óÊØçÊ£ÄÊµã‰Ωú‰∏∫ËæÖÂä©È™åËØÅ
                if (state === 'empty' && hasLetter) {
                    // Â¶ÇÊûúÈ¢úËâ≤Âà§Êñ≠‰∏∫empty‰ΩÜÊ£ÄÊµãÂà∞Â≠óÊØçÔºåÂèØËÉΩÊòØËØØÂà§
                    // ÈáçÊñ∞Ê£ÄÊü•ÊòØÂê¶Êõ¥Êé•Ëøëabsent
                    const colors = COLOR_SCHEMES[scheme];
                    const distToEmpty = colorDistance(avgColor, colors.empty);
                    const distToAbsent = colorDistance(avgColor, colors.absent);
                    if (distToAbsent < distToEmpty * 1.5) {
                        state = 'absent';
                    }
                }
            }
            // ÂØπ‰∫é correct Âíå presentÔºå‰øùÊåÅÂéüÂà§Êñ≠ÔºàËøô‰∫õÊ†ºÂ≠êËÇØÂÆöÊúâÂ≠óÊØçÔºâ
            
            // Â∞ùËØïËØÜÂà´Â≠óÊØç
            let letter = '';
            let confidence = 0;
            if (hasLetter) {
                // Ê≥®ÊÑèÔºörecognizeLetter Áé∞Âú®ÊòØÂºÇÊ≠•ÁöÑ
                // ËøôÈáåÂÖàËøîÂõûÁ©∫ÂÄºÔºåÁ®çÂêé‰ºöÂú®ÂºÇÊ≠•Â§ÑÁêÜ‰∏≠Êõ¥Êñ∞
                return {
                    row,
                    col,
                    avgColor,
                    state,
                    hasLetter,
                    letter,
                    confidence,
                    imageData // ‰øùÂ≠òimageData‰æõÂêéÁª≠OCR‰ΩøÁî®
                };
            }
            
            return {
                row,
                col,
                avgColor,
                state,
                hasLetter,
                letter,
                confidence
            };
        }
        
        function getAverageColor(imageData) {
            const data = imageData.data;
            let r = 0, g = 0, b = 0;
            let count = 0;
            
            // ÈááÊ†∑Êï¥‰∏™Ê†ºÂ≠êÔºå‰ΩÜË∑≥ËøáËæπÁºòÔºàÂèØËÉΩÊúâËæπÊ°ÜÔºâ
            const margin = Math.floor(Math.min(imageData.width, imageData.height) * 0.1);
            const startX = margin;
            const endX = imageData.width - margin;
            const startY = margin;
            const endY = imageData.height - margin;
            
            // ÊØèÈöîÂá†‰∏™ÂÉèÁ¥†ÈááÊ†∑‰∏ÄÊ¨°ÔºåÂä†Âø´ÈÄüÂ∫¶
            const step = Math.max(1, Math.floor(Math.min(imageData.width, imageData.height) / 20));
            
            for (let y = startY; y < endY; y += step) {
                for (let x = startX; x < endX; x += step) {
                    const idx = (y * imageData.width + x) * 4;
                    r += data[idx];
                    g += data[idx + 1];
                    b += data[idx + 2];
                    count++;
                }
            }
            
            if (count === 0) {
                // Â¶ÇÊûúÊ≤°ÊúâÈááÊ†∑Âà∞‰ªª‰ΩïÁÇπÔºåËøîÂõûÈªòËÆ§ÁôΩËâ≤
                return { r: 255, g: 255, b: 255 };
            }
            
            return {
                r: Math.round(r / count),
                g: Math.round(g / count),
                b: Math.round(b / count)
            };
        }
        
        // ÂÆö‰πâ‰∏çÂêåÁΩëÁ´ôÁöÑÈÖçËâ≤ÊñπÊ°à
        const COLOR_SCHEMES = {
            'wordle2.io': {
                // wordle2.ioÈÖçËâ≤
                empty: { r: 250, g: 251, b: 255 },      // #fafbff
                absent: { r: 155, g: 164, b: 187 },     // #9ba4bb
                present: { r: 236, g: 188, b: 67 },     // #ecbc43
                correct: { r: 122, g: 172, b: 80 },     // #7aac50
                tolerance: 30  // È¢úËâ≤ÂÆπÂ∑Æ
            },
            'lessgames.com': {
                // lessgames.com/wordlessÈÖçËâ≤
                empty: { r: 43, g: 46, b: 47 },         // #2b2e2f
                absent: { r: 109, g: 118, b: 124 },     // #6d767c
                present: { r: 211, g: 187, b: 51 },     // #d3bb33
                correct: { r: 96, g: 170, b: 51 },      // #60aa33
                tolerance: 30
            },
            'auto': {
                // Ëá™Âä®Ê£ÄÊµãÊ®°ÂºèÔºå‰ΩøÁî®ÂéüÊù•ÁöÑÈÄöÁî®ÁÆóÊ≥ï
                tolerance: 40
            }
        };
        
        // ËÆ°ÁÆó‰∏§‰∏™È¢úËâ≤‰πãÈó¥ÁöÑÊ¨ßÊ∞èË∑ùÁ¶ª
        function colorDistance(c1, c2) {
            return Math.sqrt(
                Math.pow(c1.r - c2.r, 2) +
                Math.pow(c1.g - c2.g, 2) +
                Math.pow(c1.b - c2.b, 2)
            );
        }
        
        function classifyColor(color) {
            const { r, g, b } = color;
            const schemeSelect = document.getElementById('colorSchemeSelect');
            const scheme = schemeSelect ? schemeSelect.value : 'auto';
            
            // Â¶ÇÊûúÈÄâÊã©‰∫ÜÁâπÂÆöÁöÑÈÖçËâ≤ÊñπÊ°à
            if (scheme !== 'auto' && COLOR_SCHEMES[scheme]) {
                const colors = COLOR_SCHEMES[scheme];
                const tolerance = colors.tolerance || 30;
                
                // ËÆ°ÁÆó‰∏éÊØèÁßçÁä∂ÊÄÅÈ¢úËâ≤ÁöÑË∑ùÁ¶ª
                const distances = {
                    empty: colorDistance(color, colors.empty),
                    absent: colorDistance(color, colors.absent),
                    present: colorDistance(color, colors.present),
                    correct: colorDistance(color, colors.correct)
                };
                
                // ÊâæÂá∫ÊúÄÊé•ËøëÁöÑÈ¢úËâ≤
                let minDistance = Infinity;
                let bestMatch = 'empty';
                
                for (const [state, distance] of Object.entries(distances)) {
                    if (distance < minDistance) {
                        minDistance = distance;
                        bestMatch = state;
                    }
                }
                
                // Â¶ÇÊûúÊúÄÂ∞èË∑ùÁ¶ªÂú®ÂÆπÂ∑ÆËåÉÂõ¥ÂÜÖÔºåËøîÂõûÂåπÈÖçÁöÑÁä∂ÊÄÅ
                if (minDistance <= tolerance) {
                    return bestMatch;
                }
                
                // Â¶ÇÊûúÊ≤°ÊúâÂ•ΩÁöÑÂåπÈÖçÔºåÊ†πÊçÆ‰∫ÆÂ∫¶ÂÅöÂü∫Êú¨Âà§Êñ≠
                const brightness = (r + g + b) / 3;
                if (brightness > 200) return 'empty';
                if (brightness < 100) return 'absent';
                return 'empty';
            }
            
            // Ëá™Âä®Ê£ÄÊµãÊ®°Âºè - ‰ΩøÁî®ÂéüÊù•ÁöÑÈÄöÁî®ÁÆóÊ≥ï
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const delta = max - min;
            
            // ÁªøËâ≤ - correct
            if (g > r && g > b && g > 100 && delta > 30) {
                if (r < g * 0.85 && b < g * 0.85) {
                    return 'correct';
                }
            }
            
            // ÈªÑËâ≤ - present
            if (r > 150 && g > 100 && delta > 30) {
                if (b < r * 0.7 && b < g * 0.7) {
                    return 'present';
                }
            }
            
            // ÁÅ∞Ëâ≤Á≥ª
            if (delta < 40) {
                if (max > 210) return 'empty';
                if (max < 120) return 'absent';
                return 'absent';
            }
            
            return 'absent';
        }
        
        function detectLetterPresence(imageData) {
            const { width, height, data } = imageData;
            
            // ËÆ°ÁÆóÊï¥‰∏™Ê†ºÂ≠êÁöÑÈ¢úËâ≤ÁªüËÆ°
            const colorStats = analyzeColorDistribution(imageData);
            
            // Âà§Êñ≠ÊòØÂê¶ÊúâÂ≠óÊØçÁöÑÂ§öÁßçÁ≠ñÁï•
            
            // Á≠ñÁï•1ÔºöÈ¢úËâ≤ÂàÜÂ∏ÉÁöÑÊ†áÂáÜÂ∑ÆÔºàÊúâÂ≠óÊØçÁöÑÊ†ºÂ≠êÈ¢úËâ≤ÂèòÂåñÊõ¥Â§ßÔºâ
            // Èôç‰ΩéÈòàÂÄºÔºåËÆ©Ê£ÄÊµãÊõ¥ÊïèÊÑü
            if (colorStats.stdDev > 20) {
                return true;
            }
            
            // Á≠ñÁï•2ÔºöÊ£ÄÊµãÊòØÂê¶ÊúâÊòéÊòæÁöÑÂèåÂ≥∞ÂàÜÂ∏ÉÔºàËÉåÊôØËâ≤ÂíåÊñáÂ≠óËâ≤Ôºâ
            if (colorStats.hasBimodal) {
                return true;
            }
            
            // Á≠ñÁï•3ÔºöËæπÁºòÊ£ÄÊµãÔºàÂ≠óÊØç‰ºö‰∫ßÁîüÊõ¥Â§öËæπÁºòÔºâ
            const edgeCount = detectEdgePixels(imageData);
            const edgeRatio = edgeCount / (width * height);
            if (edgeRatio > 0.02) { // Èôç‰ΩéÂà∞2%ÔºåÊõ¥ÂÆπÊòìÊ£ÄÊµãÂà∞Â≠óÊØç
                return true;
            }
            
            // Á≠ñÁï•4ÔºöÂØπ‰∫éÊ∑±Ëâ≤ËÉåÊôØÔºàabsentÊ†ºÂ≠êÔºâÔºåÁâπÂà´Ê£ÄÊµã‰∫ÆËâ≤ÂÉèÁ¥†
            if (colorStats.avgBrightness < 130) { // ÊèêÈ´òÈòàÂÄºÂà∞130
                // Ê∑±Ëâ≤ËÉåÊôØÔºåÊ£ÄÊü•ÊòØÂê¶ÊúâË∂≥Â§üÁöÑ‰∫ÆËâ≤ÂÉèÁ¥†ÔºàÂèØËÉΩÊòØÁôΩËâ≤Â≠óÊØçÔºâ
                if (colorStats.brightPixelRatio > 0.03) { // Èôç‰ΩéÂà∞3%
                    return true;
                }
            }
            
            // Á≠ñÁï•5ÔºöÂØπ‰∫é‰∏≠Á≠â‰∫ÆÂ∫¶ÔºàÂèØËÉΩÊòØÁÅ∞Ëâ≤absentÔºâÔºåÊ£ÄÊü•ÂØπÊØîÂ∫¶
            if (colorStats.avgBrightness >= 70 && colorStats.avgBrightness <= 140) {
                // ÁÅ∞Ëâ≤ËÉåÊôØÔºåÂ¶ÇÊûúÊúâ‰∏ÄÂÆöÊØî‰æãÁöÑÁâπÂà´‰∫ÆÊàñÁâπÂà´ÊöóÁöÑÂÉèÁ¥†ÔºåÂèØËÉΩÊúâÂ≠óÊØç
                if (colorStats.brightPixelRatio > 0.02 || colorStats.darkPixelRatio > 0.02) {
                    return true;
                }
            }
            
            return false;
        }
        
        // ÂàÜÊûêÈ¢úËâ≤ÂàÜÂ∏É
        function analyzeColorDistribution(imageData) {
            const { width, height, data } = imageData;
            const brightnesses = [];
            let sum = 0;
            let brightCount = 0;
            let darkCount = 0;
            
            // Êî∂ÈõÜÊâÄÊúâÂÉèÁ¥†ÁöÑ‰∫ÆÂ∫¶ÂÄº
            for (let i = 0; i < data.length; i += 4) {
                const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                brightnesses.push(brightness);
                sum += brightness;
                
                if (brightness > 200) brightCount++;
                if (brightness < 50) darkCount++;
            }
            
            const avg = sum / brightnesses.length;
            
            // ËÆ°ÁÆóÊ†áÂáÜÂ∑Æ
            let variance = 0;
            for (const b of brightnesses) {
                variance += Math.pow(b - avg, 2);
            }
            const stdDev = Math.sqrt(variance / brightnesses.length);
            
            // Ê£ÄÊµãÂèåÂ≥∞ÂàÜÂ∏ÉÔºàÁÆÄÂçïÁâàÊú¨ÔºöÊ£ÄÊü•ÊòØÂê¶ÂêåÊó∂ÊúâÂæàÂ§ö‰∫ÆÂÉèÁ¥†ÂíåÊöóÂÉèÁ¥†Ôºâ
            // Èôç‰ΩéÈòàÂÄºÂà∞5%ÔºåËÆ©Ê£ÄÊµãÊõ¥ÊïèÊÑü
            const hasBimodal = (brightCount > brightnesses.length * 0.05 && 
                               darkCount > brightnesses.length * 0.05);
            
            return {
                avgBrightness: avg,
                stdDev: stdDev,
                hasBimodal: hasBimodal,
                brightPixelRatio: brightCount / brightnesses.length,
                darkPixelRatio: darkCount / brightnesses.length
            };
        }
        
        // ËæπÁºòÊ£ÄÊµã
        function detectEdgePixels(imageData) {
            const { width, height, data } = imageData;
            let edgeCount = 0;
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    const center = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                    
                    // Ê£ÄÊü•Ê∞¥Âπ≥ÂíåÂûÇÁõ¥ÊñπÂêëÁöÑÊ¢ØÂ∫¶
                    const rightIdx = idx + 4;
                    const bottomIdx = idx + width * 4;
                    
                    const right = (data[rightIdx] + data[rightIdx + 1] + data[rightIdx + 2]) / 3;
                    const bottom = (data[bottomIdx] + data[bottomIdx + 1] + data[bottomIdx + 2]) / 3;
                    
                    const gradX = Math.abs(center - right);
                    const gradY = Math.abs(center - bottom);
                    
                    // Â¶ÇÊûúÊ¢ØÂ∫¶Ë∂≥Â§üÂ§ßÔºåËÆ§‰∏∫ÊòØËæπÁºò
                    // Èôç‰ΩéÈòàÂÄºÂà∞20ÔºåËÆ©Ê£ÄÊµãÊõ¥ÊïèÊÑü
                    if (gradX > 20 || gradY > 20) {
                        edgeCount++;
                    }
                }
            }
            
            return edgeCount;
        }
        
        // Â≠óÊØçËØÜÂà´ÂáΩÊï∞ÔºàÂ¢ûÂº∫ÁâàÔºåËøîÂõûË∞ÉËØï‰ø°ÊÅØÔºâ
        async function recognizeLetter(imageData, returnDebugInfo = false) {
            const debugInfo = {
                stages: [],
                confidences: {}
            };
            
            // ÂàõÂª∫‰∏¥Êó∂canvas
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = imageData.width;
            tempCanvas.height = imageData.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // ‰øùÂ≠òÂéüÂßãÂõæÂÉè
            if (returnDebugInfo) {
                const originalCanvas = document.createElement('canvas');
                originalCanvas.width = imageData.width;
                originalCanvas.height = imageData.height;
                const originalCtx = originalCanvas.getContext('2d');
                originalCtx.putImageData(imageData, 0, 0);
                debugInfo.stages.push({
                    name: 'ÂéüÂßãÂõæÂÉè',
                    canvas: originalCanvas,
                    dataUrl: originalCanvas.toDataURL()
                });
            }
            
            // È¢ÑÂ§ÑÁêÜÔºöÂ¢ûÂº∫ÂØπÊØîÂ∫¶
            const processedData = preprocessForOCR(imageData);
            tempCtx.putImageData(processedData, 0, 0);
            
            if (returnDebugInfo) {
                const processedCanvas = document.createElement('canvas');
                processedCanvas.width = imageData.width;
                processedCanvas.height = imageData.height;
                const processedCtx = processedCanvas.getContext('2d');
                processedCtx.putImageData(processedData, 0, 0);
                debugInfo.stages.push({
                    name: 'È¢ÑÂ§ÑÁêÜÂêé',
                    canvas: processedCanvas,
                    dataUrl: processedCanvas.toDataURL()
                });
            }
            
            try {
                // ‰ºòÂåñ1ÔºöÈÄÇÂ∫¶Áº©ÊîæÔºàTesseractÊúÄ‰Ω≥DPIÁ∫¶‰∏∫300Ôºâ
                // Â¶ÇÊûúÂõæÂÉèÂ§™Â∞èÔºåÊîæÂ§ßÂà∞Á∫¶100ÂÉèÁ¥†ÔºõÂê¶Âàô‰øùÊåÅÂéüÊ†∑ÊàñÈÄÇÂ∫¶ÊîæÂ§ß
                let scaleFactor = 1;
                const minSize = 50; // ÊúÄÂ∞èËæπÈïøÁõÆÊ†á
                const maxSize = 150; // ÊúÄÂ§ßËæπÈïøÁõÆÊ†á
                const currentMinSize = Math.min(imageData.width, imageData.height);
                
                if (currentMinSize < minSize) {
                    scaleFactor = minSize / currentMinSize;
                } else if (currentMinSize > maxSize) {
                    scaleFactor = maxSize / currentMinSize;
                }
                
                // ÈôêÂà∂Áº©ÊîæÂõ†Â≠êÂú®ÂêàÁêÜËåÉÂõ¥ÂÜÖ
                scaleFactor = Math.max(1, Math.min(3, scaleFactor));
                
                const scaledCanvas = document.createElement('canvas');
                scaledCanvas.width = Math.round(tempCanvas.width * scaleFactor);
                scaledCanvas.height = Math.round(tempCanvas.height * scaleFactor);
                const scaledCtx = scaledCanvas.getContext('2d');
                
                // ‰ºòÂåñ2Ôºö‰ΩøÁî®È´òË¥®ÈáèÁöÑÂõæÂÉèÁº©Êîæ
                scaledCtx.imageSmoothingEnabled = true;
                scaledCtx.imageSmoothingQuality = 'high';
                scaledCtx.drawImage(tempCanvas, 0, 0, scaledCanvas.width, scaledCanvas.height);
                
                // Ê£ÄÊµãÊòØÂê¶ÂèØËÉΩÊòØÁªÜÁ¨îÁîªÂ≠óÊØçÔºàI, T, LÁ≠âÔºâ
                const isThinStroke = detectThinStroke(processedData);
                
                // ‰ºòÂåñ3ÔºöÊ†πÊçÆÁ¨îÁîªÁ≤óÁªÜÈÄâÊã©‰∏çÂêåÁöÑOCRÈÖçÁΩÆ
                const ocrConfig = {
                    logger: m => {}, // Á¶ÅÁî®Êó•Âøó
                    
                    // Ê†∏ÂøÉÈÖçÁΩÆÔºöÂè™‰øùÁïôÊúÄÈáçË¶ÅÁöÑÂèÇÊï∞
                    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', // Âè™ËØÜÂà´Â§ßÂÜôÂ≠óÊØç
                    
                    // ‰ºòÂåñ4ÔºöÊ†πÊçÆÁ¨îÁîªÁ≤óÁªÜÈÄâÊã©PSMÊ®°Âºè
                    tessedit_pageseg_mode: isThinStroke ? '6' : '10', // ÁªÜÁ¨îÁîªÁî®PSM_SINGLE_BLOCKÔºåÂê¶ÂàôPSM_SINGLE_CHAR
                    
                    // ‰ºòÂåñ5Ôºö‰ΩøÁî®ÈªòËÆ§OCRÂºïÊìéÔºàËá™Âä®ÈÄâÊã©ÊúÄ‰Ω≥Ôºâ
                    tessedit_ocr_engine_mode: '3', // DEFAULT - Ëá™Âä®ÈÄâÊã©ÊúÄ‰Ω≥ÂºïÊìé
                    
                    // ‰ºòÂåñ6ÔºöÁÆÄÂåñÂèÇÊï∞ÔºåÈÅøÂÖçÂÜ≤Á™Å
                    classify_bln_numeric_mode: '0', // Á¶ÅÁî®Êï∞Â≠óÊ®°Âºè
                    tessedit_single_match: '0', // ÂÖÅËÆ∏Â§ö‰∏™ÂÄôÈÄâ
                };
                
                // ÂØπÁªÜÁ¨îÁîªÂ≠óÊØçÊ∑ªÂä†ÁâπÊÆäÂèÇÊï∞
                if (isThinStroke) {
                    ocrConfig.textord_min_linesize = '1.0'; // Èôç‰ΩéÊúÄÂ∞èË°åÈ´òË¶ÅÊ±Ç
                    ocrConfig.textord_excess_blobsize = '1.3'; // ÂÖÅËÆ∏Êõ¥Â∞èÁöÑblob
                }
                
                const result = await Tesseract.recognize(
                    scaledCanvas,
                    'eng',
                    ocrConfig
                );
                
                // ‰ªéÊâÄÊúâÂÄôÈÄâ‰∏≠ÈÄâÊã©ÁΩÆ‰ø°Â∫¶ÊúÄÈ´òÁöÑÂ≠óÊØç
                let letter = '';
                let confidence = 0;
                
                // ÊñπÊ≥ï1Ôºö‰ªésymbols‰∏≠ÊâæÂà∞ÁΩÆ‰ø°Â∫¶ÊúÄÈ´òÁöÑÂ≠óÊØç
                if (result.data.symbols && result.data.symbols.length > 0) {
                    let bestSymbol = null;
                    let bestConfidence = 0;
                    
                    result.data.symbols.forEach(symbol => {
                        let cleanText = symbol.text.trim().toUpperCase();
                        
                        // ÂØπÁªÜÁ¨îÁîªÁöÑÁâπÊÆäÂ§ÑÁêÜÔºö‰øÆÊ≠£Â∏∏ËßÅËØØËØÜÂà´
                        if (isThinStroke) {
                            // I Â∏∏Ë¢´ËØÜÂà´‰∏∫ 1, l, |
                            if (cleanText === '1' || cleanText === 'L' || cleanText === '|') {
                                // Â¶ÇÊûúÊòØÁªÜÁ¨îÁîª‰∏îËØÜÂà´‰∏∫Ëøô‰∫õÂ≠óÁ¨¶ÔºåÂæàÂèØËÉΩÊòØ I
                                cleanText = 'I';
                            }
                        }
                        
                        if (/^[A-Z]$/.test(cleanText) && symbol.confidence > bestConfidence) {
                            bestSymbol = cleanText;
                            bestConfidence = symbol.confidence;
                        }
                    });
                    
                    if (bestSymbol) {
                        letter = bestSymbol;
                        confidence = bestConfidence;
                    }
                }
                
                // ÊñπÊ≥ï2ÔºöÂ¶ÇÊûúÊ≤°ÊúâsymbolsÔºå‰ΩøÁî®ÂéüÂßãtext
                if (!letter && result.data.text) {
                    const text = result.data.text.trim().toUpperCase();
                    const cleanText = text.replace(/[^A-Z]/g, '');
                    if (cleanText.length > 0) {
                        letter = cleanText.charAt(0);
                        confidence = result.data.confidence || 0;
                    }
                }
                
                // Êî∂ÈõÜÊâÄÊúâÂ≠óÁ¨¶ÁöÑÁΩÆ‰ø°Â∫¶ÔºàÁî®‰∫éË∞ÉËØïÔºâ
                if (returnDebugInfo && result.data.symbols) {
                    result.data.symbols.forEach(symbol => {
                        if (/[A-Z]/.test(symbol.text)) {
                            debugInfo.confidences[symbol.text] = symbol.confidence;
                        }
                    });
                    
                    // Ê∑ªÂä†OCR‰ºòÂåñ‰ø°ÊÅØ
                    debugInfo.ocrOptimizations = {
                        scaleFactor: scaleFactor.toFixed(2),
                        psmMode: isThinStroke ? '6 (PSM_SINGLE_BLOCK)' : '10 (PSM_SINGLE_CHAR)',
                        ocrEngine: '3 (DEFAULT)',
                        originalSize: `${imageData.width}x${imageData.height}`,
                        scaledSize: `${scaledCanvas.width}x${scaledCanvas.height}`,
                        thinStroke: isThinStroke,
                        tips: [
                            scaleFactor === 1 ? 'ÂõæÂÉèÊú™Áº©ÊîæÔºàÂ∞∫ÂØ∏ÈÄÇ‰∏≠Ôºâ' : 
                            scaleFactor < 2 ? 'ÈÄÇÂ∫¶Áº©ÊîæÔºåË¥®ÈáèÊúÄ‰Ω≥' : 
                            'ÂõæÂÉèÊîæÂ§ß‰ª•ÊèêÈ´òËØÜÂà´Áéá',
                            confidence > 85 ? '‚úÖ ËØÜÂà´ÁΩÆ‰ø°Â∫¶ÂæàÈ´ò' : 
                            confidence > 70 ? '‚ö†Ô∏è ËØÜÂà´ÁΩÆ‰ø°Â∫¶‰∏≠Á≠â' : 
                            '‚ùå ËØÜÂà´ÁΩÆ‰ø°Â∫¶‰ΩéÔºåÂèØËÉΩÈúÄË¶ÅË∞ÉÊï¥',
                            isThinStroke ? 'üîç Ê£ÄÊµãÂà∞ÁªÜÁ¨îÁîªÂ≠óÊØçÔºàI/T/LÔºâÔºå‰ΩøÁî®ÁâπÊÆäÂèÇÊï∞' : 'Ê†áÂáÜÁ¨îÁîªÔºå‰ΩøÁî®Â∏∏ËßÑÂèÇÊï∞'
                        ]
                    };
                }
                
                // ÁÆÄÂåñÔºö‰∏çÂÜçÂ∞ùËØïÂ¢ûÂº∫ÂØπÊØîÂ∫¶ÔºåÁõ¥Êé•ËøîÂõûÊúÄÈ´òÁΩÆ‰ø°Â∫¶ÁöÑÁªìÊûú
                // Â¶ÇÊûúÊ≤°ÊúâËØÜÂà´Âà∞‰ªª‰ΩïÂ≠óÊØçÔºåÂ∞ùËØï‰ΩøÁî®‰∏çÂêåÁöÑPSMÊ®°Âºè
                if (!letter && imageData) {
                    console.log('Á¨¨‰∏ÄÊ¨°ËØÜÂà´Êú™ÊâæÂà∞Â≠óÊØçÔºåÂ∞ùËØïPSM_RAW_LINEÊ®°Âºè');
                    
                    // Â∞ùËØï‰∏çÂêåÁöÑPSMÊ®°ÂºèÔºàÊúâÊó∂ÂØπÁâπÊÆäÊÉÖÂÜµÊïàÊûúÊõ¥Â•ΩÔºâ
                    const result2 = await Tesseract.recognize(
                        scaledCanvas,  // ‰ΩøÁî®ÂêåÊ†∑ÁöÑÁº©ÊîæÂõæÂÉè
                        'eng',
                        {
                            logger: m => {},
                            tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
                            tessedit_pageseg_mode: '13', // PSM_RAW_LINE - ÂéüÂßãÊñáÊú¨Ë°å
                            tessedit_ocr_engine_mode: '3', // DEFAULT
                        }
                    );
                    
                    // ‰ªéÁ¨¨‰∫åÊ¨°ËØÜÂà´‰∏≠ÈÄâÊã©ÁΩÆ‰ø°Â∫¶ÊúÄÈ´òÁöÑÂ≠óÊØç
                    if (result2.data.symbols && result2.data.symbols.length > 0) {
                        result2.data.symbols.forEach(symbol => {
                            const cleanText = symbol.text.trim().toUpperCase();
                            if (/^[A-Z]$/.test(cleanText) && symbol.confidence > confidence) {
                                letter = cleanText;
                                confidence = symbol.confidence;
                                
                                if (returnDebugInfo) {
                                    debugInfo.confidences[cleanText] = symbol.confidence;
                                }
                            }
                        });
                    }
                }
                
                if (returnDebugInfo) {
                    return {
                        letter: letter,
                        confidence: Math.round(confidence),
                        debugInfo: debugInfo
                    };
                }
                
                return {
                    letter: letter,
                    confidence: Math.round(confidence)
                };
            } catch (error) {
                console.error('OCRÈîôËØØ:', error);
                // Â¶ÇÊûúOCRÂ§±Ë¥•ÔºåÂõûÈÄÄÂà∞ÁÆÄÂçïÁöÑÊ®°ÊùøÂåπÈÖç
                return fallbackLetterRecognition(imageData);
            }
        }
        
        // Ê£ÄÊµãÊòØÂê¶ÊòØÁªÜÁ¨îÁîªÔºàÂ¶ÇÂ≠óÊØçI„ÄÅT„ÄÅLÔºâ
        function detectThinStroke(imageData) {
            const { width, height, data } = imageData;
            let blackPixels = 0;
            let totalPixels = width * height;
            
            // ÁªüËÆ°ÈªëËâ≤ÂÉèÁ¥†ÔºàÊñáÂ≠óÔºâ
            for (let i = 0; i < data.length; i += 4) {
                const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                if (brightness < 128) { // ÈªëËâ≤ÊàñÊ∑±Ëâ≤
                    blackPixels++;
                }
            }
            
            const blackRatio = blackPixels / totalPixels;
            
            // Â¶ÇÊûúÈªëËâ≤ÂÉèÁ¥†Â∞ë‰∫é8%ÔºåËÆ§‰∏∫ÊòØÁªÜÁ¨îÁîª
            // IÈÄöÂ∏∏Âè™Êúâ3-5%ÔºåTÁ∫¶5-7%ÔºåLÁ∫¶6-8%
            return blackRatio < 0.08;
        }
        
        // È¢ÑÂ§ÑÁêÜÂõæÂÉè‰ª•ÊèêÈ´òOCRÂáÜÁ°ÆÂ∫¶
        function preprocessForOCR(imageData) {
            const { width, height, data } = imageData;
            const output = new ImageData(width, height);
            const outputData = output.data;
            
            // Ëé∑ÂèñÂΩìÂâçÈÖçËâ≤ÊñπÊ°à
            const schemeSelect = document.getElementById('colorSchemeSelect');
            const scheme = schemeSelect ? schemeSelect.value : 'auto';
            
            // ÁÆÄÂçïËÄåÂèØÈù†ÁöÑÊñπÊ≥ïÔºö‰ΩøÁî®Otsu'sÊñπÊ≥ïÊâæÈòàÂÄº
            // 1. ËÆ°ÁÆóÁõ¥ÊñπÂõæ
            const histogram = new Array(256).fill(0);
            let totalPixels = 0;
            for (let i = 0; i < data.length; i += 4) {
                const brightness = Math.round((data[i] + data[i + 1] + data[i + 2]) / 3);
                histogram[brightness]++;
                totalPixels++;
            }
            
            // 2. Otsu'sÊñπÊ≥ïÊâæÊúÄ‰Ω≥ÈòàÂÄº
            let sum = 0;
            for (let i = 0; i < 256; i++) {
                sum += i * histogram[i];
            }
            
            let sumB = 0;
            let wB = 0;
            let wF = 0;
            let maxVariance = 0;
            let threshold = 0;
            
            for (let t = 0; t < 256; t++) {
                wB += histogram[t];
                if (wB === 0) continue;
                
                wF = totalPixels - wB;
                if (wF === 0) break;
                
                sumB += t * histogram[t];
                
                const mB = sumB / wB;
                const mF = (sum - sumB) / wF;
                
                const variance = wB * wF * (mB - mF) * (mB - mF);
                
                if (variance > maxVariance) {
                    maxVariance = variance;
                    threshold = t;
                }
            }
            
            // 3. Âà§Êñ≠ËÉåÊôØÊòØÊ∑±Ëâ≤ËøòÊòØÊµÖËâ≤
            let darkPixels = 0;
            let lightPixels = 0;
            for (let i = 0; i < data.length; i += 4) {
                const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                if (brightness < threshold) {
                    darkPixels++;
                } else {
                    lightPixels++;
                }
            }
            
            const isDarkBackground = darkPixels > lightPixels;
            
            // 4. Ê†πÊçÆÈÖçËâ≤ÊñπÊ°àÂæÆË∞ÉÈòàÂÄº
            let adjustedThreshold = threshold;
            if (scheme === 'lessgames.com') {
                // lessgames.comÈÄöÂ∏∏ÊúâÊ∑±Ëâ≤ËÉåÊôØÔºåÁ®çÂæÆË∞ÉÊï¥ÈòàÂÄº‰ª•‰øùÁïôÊõ¥Â§öÁªÜËäÇ
                // Èôç‰ΩéÈòàÂÄºÂèØ‰ª•ËÆ©Êõ¥Â§öÂÉèÁ¥†Ë¢´ËØÜÂà´‰∏∫ÊñáÂ≠óÔºàÈÅøÂÖçÁªÜÁ¨îÁîª‰∏¢Â§±Ôºâ
                adjustedThreshold = isDarkBackground ? threshold - 15 : threshold + 15;
            } else if (scheme === 'wordle2.io') {
                // wordle2.ioÂèØËÉΩÊúâÂêÑÁßçÈ¢úËâ≤ÔºåÁ®çÂæÆË∞ÉÊï¥‰ª•‰øùÁïôÁªÜËäÇ
                adjustedThreshold = isDarkBackground ? threshold - 5 : threshold + 5;
            } else {
                // Ëá™Âä®Ê®°ÂºèÔºöËΩªÂæÆË∞ÉÊï¥
                adjustedThreshold = isDarkBackground ? threshold - 8 : threshold + 8;
            }
            
            // Á°Æ‰øùÈòàÂÄºÂú®ÊúâÊïàËåÉÂõ¥ÂÜÖ
            adjustedThreshold = Math.max(0, Math.min(255, adjustedThreshold));
            
            // Ë∞ÉËØï‰ø°ÊÅØÔºàÂèØ‰ª•Âú®ÊéßÂà∂Âè∞ÁúãÂà∞Ôºâ
            console.log(`È¢ÑÂ§ÑÁêÜË∞ÉËØï‰ø°ÊÅØ:
                OtsuÈòàÂÄº: ${threshold}
                Ë∞ÉÊï¥ÂêéÈòàÂÄº: ${adjustedThreshold}
                ËÉåÊôØÁ±ªÂûã: ${isDarkBackground ? 'Ê∑±Ëâ≤' : 'ÊµÖËâ≤'}
                Ê∑±Ëâ≤ÂÉèÁ¥†: ${darkPixels} (${(darkPixels/totalPixels*100).toFixed(1)}%)
                ÊµÖËâ≤ÂÉèÁ¥†: ${lightPixels} (${(lightPixels/totalPixels*100).toFixed(1)}%)
                ÈÖçËâ≤ÊñπÊ°à: ${scheme}
                ÁõÆÊ†á: ËæìÂá∫ÁôΩÂ∫ïÈªëÂ≠óÔºàOCRÊ†áÂáÜÊ†ºÂºèÔºâ
            `);
            
            // 5. Á¨¨‰∏ÄÊ≠•‰∫åÂÄºÂåñ
            const binaryData = new Uint8ClampedArray(width * height);
            for (let i = 0, j = 0; i < data.length; i += 4, j++) {
                const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                binaryData[j] = brightness > adjustedThreshold ? 1 : 0;
            }
            
            // 6. ÊîπËøõÁöÑÊ£ÄÊµãÊñπÊ≥ïÔºöÂàÜÊûêÂéüÂßãÂõæÂÉèÁöÑËæπÁºòÂíå‰∏≠ÂøÉ‰∫ÆÂ∫¶
            // ‰∏çÊòØÂü∫‰∫é‰∫åÂÄºÂåñÂêéÁöÑÊï∞ÊçÆÔºåËÄåÊòØÂü∫‰∫éÂéüÂßã‰∫ÆÂ∫¶
            const edgeSize = Math.floor(Math.min(width, height) * 0.15);
            let edgeBrightSum = 0, edgeCount = 0;
            let centerBrightSum = 0, centerCount = 0;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                    
                    const isEdge = x < edgeSize || x >= width - edgeSize || 
                                  y < edgeSize || y >= height - edgeSize;
                    
                    if (isEdge) {
                        edgeBrightSum += brightness;
                        edgeCount++;
                    } else {
                        centerBrightSum += brightness;
                        centerCount++;
                    }
                }
            }
            
            const edgeAvgBright = edgeBrightSum / edgeCount;
            const centerAvgBright = centerBrightSum / centerCount;
            
            // Âà§Êñ≠ÊòØÂê¶ÈúÄË¶ÅÂèçËΩ¨
            // Â¶ÇÊûú‰∏≠ÂøÉÊØîËæπÁºò‰∫ÆÔºåËØ¥ÊòéÊñáÂ≠óÊòØÁôΩËâ≤ÁöÑÔºåËÉåÊôØÊòØÊ∑±Ëâ≤ÁöÑÔºåÈúÄË¶ÅÂèçËΩ¨ÊàêÈªëÂ≠óÁôΩËÉåÊôØ
            let needInvert = false;
            
            if (centerAvgBright > edgeAvgBright + 10) {
                // ÁôΩÂ≠óÊ∑±ËÉåÊôØÔºöÈúÄË¶ÅÂèçËΩ¨ÊàêÈªëÂ≠óÁôΩËÉåÊôØ
                needInvert = true;
                console.log('Ê£ÄÊµãÂà∞ÔºöÁôΩÂ≠óÊ∑±ËÉåÊôØÔºåÈúÄË¶ÅÂèçËΩ¨');
            } else if (edgeAvgBright > centerAvgBright + 10) {
                // ÈªëÂ≠óÊµÖËÉåÊôØÔºöÂ∑≤ÁªèÊòØÊ≠£Á°ÆÊ†ºÂºè
                needInvert = false;
                console.log('Ê£ÄÊµãÂà∞ÔºöÈªëÂ≠óÊµÖËÉåÊôØÔºå‰∏çÈúÄË¶ÅÂèçËΩ¨');
            } else {
                // ÂØπÊØîÂ∫¶‰∏çÊòéÊòæÔºå‰ΩøÁî®‰∫åÂÄºÂåñÂêéÁöÑÁªüËÆ°
                let edgeWhite = 0, edgeBlack = 0;
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = y * width + x;
                        const isEdge = x < edgeSize || x >= width - edgeSize || 
                                      y < edgeSize || y >= height - edgeSize;
                        if (isEdge) {
                            if (binaryData[idx] === 1) edgeWhite++;
                            else edgeBlack++;
                        }
                    }
                }
                needInvert = edgeWhite < edgeBlack;
            }
            
            // Ê£ÄÊü•ÊòØÂê¶Êï¥‰∏™ÂõæÂÉèÂá†‰πéÂÖ®ÁôΩÊàñÂÖ®ÈªëÔºàÂèØËÉΩÊòØÈòàÂÄºÂ§±ÊïàÔºâ
            let totalWhite = 0, totalBlack = 0;
            for (let i = 0; i < binaryData.length; i++) {
                if (binaryData[i] === 1) totalWhite++;
                else totalBlack++;
            }
            
            // ÁâπÊÆäÊÉÖÂÜµÂ§ÑÁêÜÔºöÂ¶ÇÊûúÂõæÂÉèÂá†‰πéÂÖ®ÁôΩÊàñÂÖ®ÈªëÔºàOtsuÂ§±ÊïàÔºâ
            if (totalWhite > totalPixels * 0.95 || totalBlack > totalPixels * 0.95) {
                console.log('Ë≠¶ÂëäÔºöOtsuÈòàÂÄºÂèØËÉΩÂ§±ÊïàÔºå‰ΩøÁî®Â§áÁî®ÊñπÊ≥ï');
                
                // Â§áÁî®ÊñπÊ≥ïÔºöÈáçÊñ∞ËÆ°ÁÆóÈòàÂÄº
                // ÊâæÊúÄ‰∫ÆÂíåÊúÄÊöóÁöÑ10%ÂÉèÁ¥†ÁöÑÂπ≥ÂùáÂÄº
                const sortedBrightness = [];
                for (let i = 0; i < data.length; i += 4) {
                    sortedBrightness.push((data[i] + data[i + 1] + data[i + 2]) / 3);
                }
                sortedBrightness.sort((a, b) => a - b);
                
                const tenPercent = Math.floor(sortedBrightness.length * 0.1);
                let darkAvg = 0, lightAvg = 0;
                
                for (let i = 0; i < tenPercent; i++) {
                    darkAvg += sortedBrightness[i];
                    lightAvg += sortedBrightness[sortedBrightness.length - 1 - i];
                }
                darkAvg /= tenPercent;
                lightAvg /= tenPercent;
                
                // ‰ΩøÁî®Êñ∞ÈòàÂÄºÈáçÊñ∞‰∫åÂÄºÂåñ
                const newThreshold = (darkAvg + lightAvg) / 2;
                console.log(`‰ΩøÁî®Â§áÁî®ÈòàÂÄº: ${newThreshold} (ÂéüOtsu: ${threshold})`);
                
                // ÈáçÊñ∞‰∫åÂÄºÂåñ
                for (let i = 0, j = 0; i < data.length; i += 4, j++) {
                    const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    binaryData[j] = brightness > newThreshold ? 1 : 0;
                }
                
                // ÈáçÊñ∞ÁªüËÆ°‰ª•ÂÜ≥ÂÆöÊòØÂê¶ÂèçËΩ¨
                let newWhiteCount = 0;
                for (let i = 0; i < binaryData.length; i++) {
                    if (binaryData[i] === 1) newWhiteCount++;
                }
                
                // ‰∏ÄËà¨ÊÉÖÂÜµ‰∏ãÔºåËÉåÊôØÂÉèÁ¥†Êõ¥Â§öÔºåÊñáÂ≠óÂÉèÁ¥†Êõ¥Â∞ë
                // Â¶ÇÊûúÁôΩËâ≤ÂÉèÁ¥†Êõ¥Â§öÔºåËØ¥ÊòéÁôΩËâ≤ÊòØËÉåÊôØÔºå‰∏çÈúÄË¶ÅÂèçËΩ¨ÔºàÂ∑≤ÁªèÊòØOCRÊ†áÂáÜÊ†ºÂºèÔºâ
                // Â¶ÇÊûúÈªëËâ≤ÂÉèÁ¥†Êõ¥Â§öÔºåËØ¥ÊòéÈªëËâ≤ÊòØËÉåÊôØÔºåÈúÄË¶ÅÂèçËΩ¨‰∏∫ÁôΩÂ∫ïÈªëÂ≠ó
                needInvert = newWhiteCount <= binaryData.length * 0.5;
            }
            
            console.log(`È¢úËâ≤ÂàÜÂ∏É:
                ËæπÁºòÂπ≥Âùá‰∫ÆÂ∫¶: ${edgeAvgBright.toFixed(1)}
                ‰∏≠ÂøÉÂπ≥Âùá‰∫ÆÂ∫¶: ${centerAvgBright.toFixed(1)}
                ‰∫ÆÂ∫¶Â∑Æ: ${(centerAvgBright - edgeAvgBright).toFixed(1)}
                ÈúÄË¶ÅÂèçËΩ¨: ${needInvert} (ÁõÆÊ†áÔºöÁôΩÂ∫ïÈªëÂ≠ó)
            `);
            
            // 7. ÂèØÈÄâÔºöÂØπÁªÜÁ¨îÁîªËøõË°åËΩªÂæÆËÜ®ËÉÄÔºàÁâπÂà´ÊòØT„ÄÅI„ÄÅLÁ≠âÔºâ
            // ËÆ°ÁÆóÈªëËâ≤ÂÉèÁ¥†ÁöÑÊØî‰æã
            let blackPixelRatio = 0;
            for (let i = 0; i < binaryData.length; i++) {
                if ((needInvert && binaryData[i] === 1) || (!needInvert && binaryData[i] === 0)) {
                    blackPixelRatio++;
                }
            }
            blackPixelRatio /= binaryData.length;
            
            // Â¶ÇÊûúÈªëËâ≤ÂÉèÁ¥†Â§™Â∞ëÔºà<5%ÔºâÔºåÂèØËÉΩÊòØÁªÜÁ¨îÁîªÔºåËøõË°åËΩªÂæÆËÜ®ËÉÄ
            const dilatedData = new Uint8ClampedArray(binaryData);
            if (blackPixelRatio < 0.05 && blackPixelRatio > 0.01) {
                console.log('Ê£ÄÊµãÂà∞ÁªÜÁ¨îÁîªÔºåËøõË°åËΩªÂæÆËÜ®ËÉÄÂ§ÑÁêÜ');
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = y * width + x;
                        // Â¶ÇÊûúÂë®Âõ¥ÊúâÈªëËâ≤ÂÉèÁ¥†ÔºåÂΩìÂâçÂÉèÁ¥†‰πüÂèòÈªëÔºà3x3ËÜ®ËÉÄÔºâ
                        const targetValue = needInvert ? 1 : 0;
                        if (binaryData[idx - width] === targetValue ||
                            binaryData[idx + width] === targetValue ||
                            binaryData[idx - 1] === targetValue ||
                            binaryData[idx + 1] === targetValue) {
                            dilatedData[idx] = targetValue;
                        }
                    }
                }
            }
            
            // 8. ÁîüÊàêÊúÄÁªàÁöÑÁôΩÂ∫ïÈªëÂ≠óÂõæÂÉèÔºàOCRÊ†áÂáÜÊ†ºÂºèÔºâ
            for (let i = 0, j = 0; i < outputData.length; i += 4, j++) {
                let pixelValue;
                const useData = blackPixelRatio < 0.05 && blackPixelRatio > 0.01 ? dilatedData : binaryData;
                
                if (needInvert) {
                    // ÈúÄË¶ÅÂèçËΩ¨ÔºàÊ∑±Ëâ≤ËÉåÊôØ ‚Üí ÁôΩÂ∫ïÈªëÂ≠óÔºâÔºö1ÔºàÁôΩÔºâÂèò0ÔºàÈªëÔºâÔºå0ÔºàÈªëÔºâÂèò255ÔºàÁôΩÔºâ
                    pixelValue = useData[j] === 1 ? 0 : 255;
                } else {
                    // ‰∏çÈúÄË¶ÅÂèçËΩ¨ÔºàÂ∑≤ÁªèÊòØÁôΩÂ∫ïÈªëÂ≠óÔºâÔºö1ÔºàÁôΩÔºâ‰øùÊåÅ255ÔºàÁôΩÔºâÔºå0ÔºàÈªëÔºâ‰øùÊåÅ0ÔºàÈªëÔºâ
                    pixelValue = useData[j] === 1 ? 255 : 0;
                }
                
                outputData[i] = pixelValue;
                outputData[i + 1] = pixelValue;
                outputData[i + 2] = pixelValue;
                outputData[i + 3] = 255;
            }
            
            return output;
        }
        
        // Â¢ûÂº∫ÂØπÊØîÂ∫¶ÁöÑÈ¢ÑÂ§ÑÁêÜÔºàÊõ¥ÊøÄËøõÁöÑÊñπÊ≥ïÔºâ
        function enhanceContrastForOCR(imageData) {
            const { width, height, data } = imageData;
            
            // Á¨¨‰∏ÄÊ≠•Ôºö‰ΩøÁî®ÊîπËøõÁöÑËá™ÈÄÇÂ∫îÈòàÂÄºÂ§ÑÁêÜ
            const enhanced1 = applyAdaptiveThreshold(imageData);
            
            // Á¨¨‰∫åÊ≠•ÔºöÂΩ¢ÊÄÅÂ≠¶Èó≠ËøêÁÆóÔºàËøûÊé•Êñ≠ÂºÄÁöÑÁ¨îÁîªÔºâ
            const enhanced2 = applyMorphologicalClosing(enhanced1, width, height);
            
            // Á¨¨‰∏âÊ≠•ÔºöÂéªÈô§Â∞èÂô™ÁÇπ
            const enhanced3 = removeSmallNoise(enhanced2, width, height);
            
            return enhanced3;
        }
        
        // Ëá™ÈÄÇÂ∫îÈòàÂÄºÂ§ÑÁêÜ
        function applyAdaptiveThreshold(imageData) {
            const { width, height, data } = imageData;
            const output = new ImageData(width, height);
            const outputData = output.data;
            
            // ËÆ°ÁÆóÂ±ÄÈÉ®Âπ≥ÂùáÂÄºÂíåÊ†áÂáÜÂ∑Æ
            const windowSize = Math.max(3, Math.min(width, height) / 8);
            const halfWindow = Math.floor(windowSize / 2);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const centerIdx = (y * width + x) * 4;
                    
                    // ËÆ°ÁÆóÁ™óÂè£ÂÜÖÁöÑÁªüËÆ°‰ø°ÊÅØ
                    let sum = 0, count = 0, sumSquared = 0;
                    
                    for (let dy = -halfWindow; dy <= halfWindow; dy++) {
                        for (let dx = -halfWindow; dx <= halfWindow; dx++) {
                            const ny = y + dy;
                            const nx = x + dx;
                            if (ny >= 0 && ny < height && nx >= 0 && nx < width) {
                                const idx = (ny * width + nx) * 4;
                                const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                                sum += brightness;
                                sumSquared += brightness * brightness;
                                count++;
                            }
                        }
                    }
                    
                    const mean = sum / count;
                    const variance = (sumSquared / count) - (mean * mean);
                    const stdDev = Math.sqrt(variance);
                    
                    // ÂΩìÂâçÂÉèÁ¥†ÁöÑ‰∫ÆÂ∫¶
                    const currentBrightness = (data[centerIdx] + data[centerIdx + 1] + data[centerIdx + 2]) / 3;
                    
                    // Ëá™ÈÄÇÂ∫îÈòàÂÄºÔºöÂùáÂÄº - k * Ê†áÂáÜÂ∑Æ
                    const k = 0.2;
                    const threshold = mean - k * stdDev;
                    
                    // ‰∫åÂÄºÂåñÂÜ≥Á≠ñ
                    const isText = currentBrightness < threshold;
                    const value = isText ? 0 : 255; // ÈªëÂ≠óÁôΩÂ∫ï
                    
                    outputData[centerIdx] = outputData[centerIdx + 1] = outputData[centerIdx + 2] = value;
                    outputData[centerIdx + 3] = 255;
                }
            }
            
            return output;
        }
        
        // ÂΩ¢ÊÄÅÂ≠¶Èó≠ËøêÁÆóÔºàÂÖàËÜ®ËÉÄÂêéËÖêËöÄÔºåËøûÊé•Êñ≠ÂºÄÁöÑÁ¨îÁîªÔºâ
        function applyMorphologicalClosing(imageData, width, height) {
            // ËÜ®ËÉÄÊìç‰Ωú
            const dilated = applyDilation(imageData, width, height);
            // ËÖêËöÄÊìç‰Ωú
            const closed = applyErosion(dilated, width, height);
            return closed;
        }
        
        // ËÜ®ËÉÄÊìç‰Ωú
        function applyDilation(imageData, width, height) {
            const output = new ImageData(width, height);
            const data = imageData.data;
            const outputData = output.data;
            
            // 3x3ÁªìÊûÑÂÖÉÁ¥†
            const kernel = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 0], [0, 1], [1, -1], [1, 0], [1, 1]];
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let hasBlackNeighbor = false;
                    
                    for (const [dy, dx] of kernel) {
                        const ny = y + dy;
                        const nx = x + dx;
                        const idx = (ny * width + nx) * 4;
                        if (data[idx] === 0) { // Â¶ÇÊûúÈÇªÂüüÊúâÈªëÂÉèÁ¥†
                            hasBlackNeighbor = true;
                            break;
                        }
                    }
                    
                    const currentIdx = (y * width + x) * 4;
                    const value = hasBlackNeighbor ? 0 : 255;
                    outputData[currentIdx] = outputData[currentIdx + 1] = outputData[currentIdx + 2] = value;
                    outputData[currentIdx + 3] = 255;
                }
            }
            
            // Â§çÂà∂ËæπÁïå
            for (let i = 0; i < data.length; i += 4) {
                if (outputData[i + 3] === 0) { // Êú™Â§ÑÁêÜÁöÑÂÉèÁ¥†
                    outputData[i] = data[i];
                    outputData[i + 1] = data[i + 1];
                    outputData[i + 2] = data[i + 2];
                    outputData[i + 3] = 255;
                }
            }
            
            return output;
        }
        
        // ËÖêËöÄÊìç‰Ωú
        function applyErosion(imageData, width, height) {
            const output = new ImageData(width, height);
            const data = imageData.data;
            const outputData = output.data;
            
            // 3x3ÁªìÊûÑÂÖÉÁ¥†
            const kernel = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 0], [0, 1], [1, -1], [1, 0], [1, 1]];
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let allNeighborsBlack = true;
                    
                    for (const [dy, dx] of kernel) {
                        const ny = y + dy;
                        const nx = x + dx;
                        const idx = (ny * width + nx) * 4;
                        if (data[idx] !== 0) { // Â¶ÇÊûúÈÇªÂüüÊúâÁôΩÂÉèÁ¥†
                            allNeighborsBlack = false;
                            break;
                        }
                    }
                    
                    const currentIdx = (y * width + x) * 4;
                    const value = allNeighborsBlack ? 0 : 255;
                    outputData[currentIdx] = outputData[currentIdx + 1] = outputData[currentIdx + 2] = value;
                    outputData[currentIdx + 3] = 255;
                }
            }
            
            // Â§çÂà∂ËæπÁïå
            for (let i = 0; i < data.length; i += 4) {
                if (outputData[i + 3] === 0) { // Êú™Â§ÑÁêÜÁöÑÂÉèÁ¥†
                    outputData[i] = data[i];
                    outputData[i + 1] = data[i + 1];
                    outputData[i + 2] = data[i + 2];
                    outputData[i + 3] = 255;
                }
            }
            
            return output;
        }
        
        // ÂéªÈô§Â∞èÂô™ÁÇπ
        function removeSmallNoise(imageData, width, height) {
            const output = new ImageData(width, height);
            const data = imageData.data;
            const outputData = output.data;
            
            // Â§çÂà∂ÂéüÂßãÊï∞ÊçÆ
            for (let i = 0; i < data.length; i++) {
                outputData[i] = data[i];
            }
            
            // ËøûÈÄöÁªÑ‰ª∂ÂàÜÊûêÔºåÂéªÈô§Â∞èÁöÑÈªëËâ≤Âå∫Âüü
            const visited = new Array(width * height).fill(false);
            const minComponentSize = Math.max(3, (width * height) / 100); // Ëá≥Â∞ëË¶ÅÊúâ1%ÁöÑÂÉèÁ¥†
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    if (!visited[idx] && data[idx * 4] === 0) { // ÈªëËâ≤ÂÉèÁ¥†‰∏îÊú™ËÆøÈóÆ
                        const component = floodFill(data, visited, x, y, width, height);
                        if (component.length < minComponentSize) {
                            // Â∞ÜÂ∞èÁªÑ‰ª∂Âèò‰∏∫ÁôΩËâ≤
                            for (const pixelIdx of component) {
                                outputData[pixelIdx * 4] = 255;
                                outputData[pixelIdx * 4 + 1] = 255;
                                outputData[pixelIdx * 4 + 2] = 255;
                            }
                        }
                    }
                }
            }
            
            return output;
        }
        
        // Ê≥õÊ¥™Â°´ÂÖÖÁÆóÊ≥ï
        function floodFill(data, visited, startX, startY, width, height) {
            const stack = [{x: startX, y: startY}];
            const component = [];
            
            while (stack.length > 0) {
                const {x, y} = stack.pop();
                const idx = y * width + x;
                
                if (x < 0 || x >= width || y < 0 || y >= height || visited[idx] || data[idx * 4] !== 0) {
                    continue;
                }
                
                visited[idx] = true;
                component.push(idx);
                
                // Ê∑ªÂä†4ËøûÈÄöÈÇªÂüü
                stack.push({x: x + 1, y: y});
                stack.push({x: x - 1, y: y});
                stack.push({x: x, y: y + 1});
                stack.push({x: x, y: y - 1});
            }
            
            return component;
        }
        
        // ÁÆÄÂçïÁöÑÂêéÂ§áÂ≠óÊØçËØÜÂà´
        function fallbackLetterRecognition(imageData) {
            // ‰øùÁïôÂéüÊù•ÁöÑÁÆÄÂçïÊ®°ÊùøÂåπÈÖç‰Ωú‰∏∫ÂêéÂ§á
            const letterImage = extractLetterRegion(imageData);
            const features = extractLetterFeatures(letterImage);
            const result = matchLetterTemplate(features);
            return result;
        }
        
        // ÊèêÂèñÂ≠óÊØçÂå∫ÂüüÔºàÂéªÈô§ËÉåÊôØÔºâ
        function extractLetterRegion(imageData) {
            const { width, height, data } = imageData;
            const binaryImage = new Uint8ClampedArray(width * height);
            
            // ÂÖàÊâæÂà∞ËÉåÊôØËâ≤ÔºàËæπÁºòÁöÑ‰∏ªË¶ÅÈ¢úËâ≤Ôºâ
            let bgBrightness = 0;
            let bgCount = 0;
            const edgeWidth = Math.floor(width * 0.1);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    // Âè™ÈááÊ†∑ËæπÁºò
                    if (x < edgeWidth || x >= width - edgeWidth || 
                        y < edgeWidth || y >= height - edgeWidth) {
                        const idx = (y * width + x) * 4;
                        bgBrightness += (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                        bgCount++;
                    }
                }
            }
            
            const avgBg = bgCount > 0 ? bgBrightness / bgCount : 128;
            
            // Âä®ÊÄÅÈòàÂÄºÔºöËÉåÊôØ‰∫ÆÂ∫¶ÁöÑ‰∏≠ÁÇπ
            const threshold = avgBg > 128 ? avgBg - 40 : avgBg + 40;
            
            // ËΩ¨Êç¢‰∏∫‰∫åÂÄºÂõæÂÉèÔºåÊ†πÊçÆËÉåÊôØÊòØÊ∑±Ëâ≤ËøòÊòØÊµÖËâ≤ÂÜ≥ÂÆöÂèçËΩ¨
            const invertColors = avgBg < 128;
            
            for (let i = 0; i < data.length; i += 4) {
                const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                if (invertColors) {
                    // Ê∑±Ëâ≤ËÉåÊôØÔºåÊµÖËâ≤ÊñáÂ≠ó
                    binaryImage[i / 4] = brightness > threshold ? 1 : 0;
                } else {
                    // ÊµÖËâ≤ËÉåÊôØÔºåÊ∑±Ëâ≤ÊñáÂ≠ó
                    binaryImage[i / 4] = brightness < threshold ? 1 : 0;
                }
            }
            
            // ÊâæÂà∞Â≠óÊØçÁöÑËæπÁïå
            let minX = width, maxX = 0;
            let minY = height, maxY = 0;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (binaryImage[y * width + x] === 1) {
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                    }
                }
            }
            
            // Â¶ÇÊûúÊ≤°ÊúâÊâæÂà∞Â≠óÊØçÂå∫Âüü
            if (minX > maxX || minY > maxY) {
                return { data: binaryImage, width, height, bounds: null };
            }
            
            return {
                data: binaryImage,
                width,
                height,
                bounds: { minX, maxX, minY, maxY }
            };
        }
        
        // ÊèêÂèñÂ≠óÊØçÁâπÂæÅ
        function extractLetterFeatures(letterImage) {
            const { data, width, height, bounds } = letterImage;
            
            if (!bounds) {
                return { 
                    verticalProfile: [], 
                    horizontalProfile: [],
                    density: 0,
                    aspectRatio: 1
                };
            }
            
            const { minX, maxX, minY, maxY } = bounds;
            const letterWidth = maxX - minX + 1;
            const letterHeight = maxY - minY + 1;
            
            // ÂûÇÁõ¥ÊäïÂΩ±ÔºàÊØèÂàóÁöÑÈªëÁÇπÊï∞Ôºâ
            const verticalProfile = [];
            for (let x = minX; x <= maxX; x++) {
                let count = 0;
                for (let y = minY; y <= maxY; y++) {
                    if (data[y * width + x] === 1) count++;
                }
                verticalProfile.push(count / letterHeight);
            }
            
            // Ê∞¥Âπ≥ÊäïÂΩ±ÔºàÊØèË°åÁöÑÈªëÁÇπÊï∞Ôºâ
            const horizontalProfile = [];
            for (let y = minY; y <= maxY; y++) {
                let count = 0;
                for (let x = minX; x <= maxX; x++) {
                    if (data[y * width + x] === 1) count++;
                }
                horizontalProfile.push(count / letterWidth);
            }
            
            // ÂØÜÂ∫¶ÁâπÂæÅ
            let blackPixels = 0;
            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    if (data[y * width + x] === 1) blackPixels++;
                }
            }
            const density = blackPixels / (letterWidth * letterHeight);
            
            // ÂÆΩÈ´òÊØî
            const aspectRatio = letterWidth / letterHeight;
            
            return {
                verticalProfile,
                horizontalProfile,
                density,
                aspectRatio,
                width: letterWidth,
                height: letterHeight
            };
        }
        
        // Ê®°ÊùøÂåπÈÖçËØÜÂà´Â≠óÊØç
        function matchLetterTemplate(features) {
            // ÁÆÄÂåñÁöÑÂ≠óÊØçÁâπÂæÅÊ®°Êùø
            const templates = {
                'A': { density: 0.35, aspectRatio: 0.7, hasHole: true },
                'B': { density: 0.45, aspectRatio: 0.6, hasHole: true },
                'C': { density: 0.30, aspectRatio: 0.7, hasHole: false },
                'D': { density: 0.40, aspectRatio: 0.7, hasHole: true },
                'E': { density: 0.35, aspectRatio: 0.6, hasHole: false },
                'F': { density: 0.30, aspectRatio: 0.6, hasHole: false },
                'G': { density: 0.35, aspectRatio: 0.7, hasHole: false },
                'H': { density: 0.35, aspectRatio: 0.7, hasHole: false },
                'I': { density: 0.25, aspectRatio: 0.3, hasHole: false },
                'J': { density: 0.25, aspectRatio: 0.5, hasHole: false },
                'K': { density: 0.35, aspectRatio: 0.7, hasHole: false },
                'L': { density: 0.25, aspectRatio: 0.6, hasHole: false },
                'M': { density: 0.40, aspectRatio: 0.8, hasHole: false },
                'N': { density: 0.35, aspectRatio: 0.7, hasHole: false },
                'O': { density: 0.35, aspectRatio: 0.8, hasHole: true },
                'P': { density: 0.35, aspectRatio: 0.6, hasHole: true },
                'Q': { density: 0.40, aspectRatio: 0.8, hasHole: true },
                'R': { density: 0.40, aspectRatio: 0.7, hasHole: true },
                'S': { density: 0.35, aspectRatio: 0.6, hasHole: false },
                'T': { density: 0.25, aspectRatio: 0.7, hasHole: false },
                'U': { density: 0.30, aspectRatio: 0.7, hasHole: false },
                'V': { density: 0.30, aspectRatio: 0.8, hasHole: false },
                'W': { density: 0.40, aspectRatio: 0.9, hasHole: false },
                'X': { density: 0.30, aspectRatio: 0.7, hasHole: false },
                'Y': { density: 0.25, aspectRatio: 0.7, hasHole: false },
                'Z': { density: 0.30, aspectRatio: 0.7, hasHole: false }
            };
            
            let bestMatch = '';
            let bestScore = 0;
            
            // Âü∫‰∫éÂØÜÂ∫¶ÂíåÂÆΩÈ´òÊØîÁöÑÁÆÄÂçïÂåπÈÖç
            for (const [letter, template] of Object.entries(templates)) {
                const densityDiff = Math.abs(features.density - template.density);
                const aspectDiff = Math.abs(features.aspectRatio - template.aspectRatio);
                
                // ËÆ°ÁÆóÁõ∏‰ººÂ∫¶ÂæóÂàÜ
                const score = Math.max(0, 1 - densityDiff * 2 - aspectDiff);
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMatch = letter;
                }
            }
            
            // Â¶ÇÊûúÁâπÂæÅÂ§™Âº±ÔºåËøîÂõûÁ©∫
            if (features.density < 0.1 || bestScore < 0.3) {
                return { letter: '', confidence: 0 };
            }
            
            return {
                letter: bestMatch,
                confidence: Math.round(bestScore * 100)
            };
        }
        
        // ÊòæÁ§∫OCRË∞ÉËØïÈù¢Êùø
        async function showDebugPanel(cellData, row, col) {
            const panel = document.getElementById('ocrDebugPanel');
            const debugContent = document.getElementById('debugContent');
            const confidenceChart = document.getElementById('confidenceChart');
            
            // ÊòæÁ§∫Âä†ËΩΩ‰∏≠
            debugContent.innerHTML = '<p>Ê≠£Âú®ÂàÜÊûêÂ≠óÊØçËØÜÂà´ËøáÁ®ã...</p>';
            confidenceChart.innerHTML = '';
            panel.classList.add('active');
            
            // ÊâßË°åÂ∏¶Ë∞ÉËØï‰ø°ÊÅØÁöÑËØÜÂà´
            const result = await recognizeLetter(cellData, true);
            
            // ÊòæÁ§∫ÂêÑ‰∏™Èò∂ÊÆµÁöÑÂõæÂÉè
            debugContent.innerHTML = '';
            if (result.debugInfo && result.debugInfo.stages) {
                result.debugInfo.stages.forEach(stage => {
                    const stageDiv = document.createElement('div');
                    stageDiv.className = 'debug-stage';
                    stageDiv.innerHTML = `
                        <h4>${stage.name}</h4>
                        <img src="${stage.dataUrl}" class="debug-canvas" />
                    `;
                    debugContent.appendChild(stageDiv);
                });
            }
            
            // ÊòæÁ§∫ÁΩÆ‰ø°Â∫¶ÂõæË°®
            confidenceChart.innerHTML = '<h4>Â≠óÊØçÁΩÆ‰ø°Â∫¶ÂàÜÂ∏É</h4>';
            
            // Ëé∑ÂèñÊâÄÊúâÂ≠óÊØçÁöÑÁΩÆ‰ø°Â∫¶
            const confidences = result.debugInfo?.confidences || {};
            
            // Â¶ÇÊûúÊúâËØÜÂà´ÁªìÊûúÔºåÁ°Æ‰øùÂÆÉÂú®ÂàóË°®‰∏≠
            if (result.letter && !confidences[result.letter]) {
                confidences[result.letter] = result.confidence;
            }
            
            // ÊéíÂ∫èÂπ∂ÊòæÁ§∫Ââç10‰∏™
            const sortedConfidences = Object.entries(confidences)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            if (sortedConfidences.length === 0) {
                confidenceChart.innerHTML += '<p style="color: #999;">Êú™Ê£ÄÊµãÂà∞‰ªª‰ΩïÂ≠óÊØç</p>';
            } else {
                sortedConfidences.forEach(([letter, conf]) => {
                    const barDiv = document.createElement('div');
                    barDiv.className = 'confidence-bar';
                    const isSelected = letter === result.letter;
                    barDiv.innerHTML = `
                        <div class="confidence-bar-label" style="${isSelected ? 'color: #4CAF50; font-weight: bold;' : ''}">${letter}</div>
                        <div class="confidence-bar-track">
                            <div class="confidence-bar-fill" style="width: ${conf}%; background: ${isSelected ? '#4CAF50' : '#888'};"></div>
                        </div>
                        <div class="confidence-bar-value">${Math.round(conf)}%</div>
                    `;
                    confidenceChart.appendChild(barDiv);
                });
            }
            
            // Ê∑ªÂä†Ê±áÊÄª‰ø°ÊÅØ
            const summaryDiv = document.createElement('div');
            summaryDiv.className = 'debug-info';
            summaryDiv.innerHTML = `
                <strong>ËØÜÂà´ÁªìÊûúÔºö</strong> ${result.letter || 'Êó†'}<br>
                <strong>ÁΩÆ‰ø°Â∫¶Ôºö</strong> ${result.confidence}%<br>
                <strong>Ê†ºÂ≠ê‰ΩçÁΩÆÔºö</strong> [${row}, ${col}]
            `;
            confidenceChart.appendChild(summaryDiv);
        }
        
        function closeDebugPanel() {
            document.getElementById('ocrDebugPanel').classList.remove('active');
        }
        
        function createCellAnalysisUI(analysis, cellData) {
            const div = document.createElement('div');
            div.className = 'cell-analysis';
            
            // Ê∑ªÂä†ÁÇπÂáª‰∫ã‰ª∂
            div.onclick = () => {
                if (analysis.hasLetter) {
                    showDebugPanel(cellData, analysis.row, analysis.col);
                }
            };
            
            // ÂàõÂª∫Â∞èÁîªÂ∏ÉÊòæÁ§∫Ê†ºÂ≠ê
            const canvas = document.createElement('canvas');
            canvas.width = 60;
            canvas.height = 60;
            canvas.className = 'cell-preview';
            const ctx = canvas.getContext('2d');
            
            // Áº©ÊîæÂπ∂ÁªòÂà∂Ê†ºÂ≠êÊï∞ÊçÆÂà∞60x60ÁöÑÁîªÂ∏É
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = cellData.width;
            tempCanvas.height = cellData.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(cellData, 0, 0);
            
            ctx.drawImage(tempCanvas, 0, 0, cellData.width, cellData.height, 0, 0, 60, 60);
            
            div.innerHTML = `
                <div class="cell-header">
                    <div class="cell-info">
                        <div>Ê†ºÂ≠ê [${analysis.row}, ${analysis.col}]</div>
                        <div style="margin-top: 5px;">
                            <span class="color-box" style="background: rgb(${analysis.avgColor.r}, ${analysis.avgColor.g}, ${analysis.avgColor.b})"></span>
                            <span style="font-size: 12px;">RGB(${analysis.avgColor.r}, ${analysis.avgColor.g}, ${analysis.avgColor.b})</span>
                        </div>
                        <div style="margin-top: 5px;">
                            <span class="state-badge state-${analysis.state}">${analysis.state.toUpperCase()}</span>
                            ${analysis.hasLetter ? '<span style="margin-left: 5px; color: green;">‚úì ÊúâÂ≠óÊØç</span>' : '<span style="margin-left: 5px; color: #999;">‚úó Êó†Â≠óÊØç</span>'}
                        </div>
                        ${analysis.letter ? `
                        <div style="margin-top: 5px; background: #e3f2fd; padding: 5px; border-radius: 3px;">
                            <strong style="font-size: 18px; color: #1976d2;">${analysis.letter}</strong>
                            <span style="margin-left: 10px; font-size: 12px; color: #666;">ÁΩÆ‰ø°Â∫¶: ${analysis.confidence}%</span>
                        </div>
                        ` : ''}
                        ${analysis.hasLetter ? '<div style="margin-top: 5px; font-size: 11px; color: #1976d2;">üîç ÁÇπÂáªÊü•ÁúãOCRË∞ÉËØï‰ø°ÊÅØ</div>' : ''}
                    </div>
                </div>
            `;
            
            div.insertBefore(canvas, div.firstChild);
            
            return div;
        }
        
        function displayGameState(gameRows, container) {
            // Ê∏ÖÁ©∫ÂÆπÂô®
            container.innerHTML = '';
            
            // ÁªüËÆ°‰ø°ÊÅØ
            let totalCells = 0;
            let recognizedLetters = 0;
            let totalConfidence = 0;
            let letterCounts = {};
            
            // ÂàõÂª∫Ê∏∏ÊàèÊùøÊòæÁ§∫
            const boardDiv = document.createElement('div');
            boardDiv.className = 'game-board';
            
            gameRows.forEach(row => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'wordle-row';
                
                row.forEach(cell => {
                    totalCells++;
                    const cellDiv = document.createElement('div');
                    cellDiv.className = `wordle-cell ${cell.state !== 'empty' ? cell.state : ''}`;
                    
                    if (cell.letter) {
                        cellDiv.textContent = cell.letter;
                        recognizedLetters++;
                        totalConfidence += cell.confidence;
                        letterCounts[cell.letter] = (letterCounts[cell.letter] || 0) + 1;
                        
                        // Ê∑ªÂä†ÁΩÆ‰ø°Â∫¶Ê†áÁ≠æ
                        if (cell.confidence > 0) {
                            const badge = document.createElement('span');
                            badge.className = 'confidence-badge';
                            badge.textContent = `${cell.confidence}%`;
                            cellDiv.appendChild(badge);
                        }
                    } else if (cell.hasLetter) {
                        cellDiv.textContent = '?';
                    }
                    
                    rowDiv.appendChild(cellDiv);
                });
                
                boardDiv.appendChild(rowDiv);
            });
            
            container.appendChild(boardDiv);
            
            // Ê∑ªÂä†ËØÜÂà´ÁªüËÆ°ÊëòË¶Å
            const summaryDiv = document.createElement('div');
            summaryDiv.className = 'recognition-summary';
            
            const avgConfidence = recognizedLetters > 0 ? Math.round(totalConfidence / recognizedLetters) : 0;
            const recognitionRate = totalCells > 0 ? Math.round((recognizedLetters / totalCells) * 100) : 0;
            
            // ÊâæÂá∫ËØÜÂà´Âà∞ÁöÑÂçïËØç
            const recognizedWords = [];
            gameRows.forEach(row => {
                const word = row.map(cell => cell.letter || '_').join('');
                if (word.indexOf('_') === -1 && word.length > 0) {
                    recognizedWords.push(word);
                }
            });
            
            summaryDiv.innerHTML = `
                <h3>üìä ËØÜÂà´ÁªüËÆ°</h3>
                <div class="summary-stats">
                    <div class="stat-card">
                        <div class="stat-value">${recognizedLetters}/${totalCells}</div>
                        <div class="stat-label">ËØÜÂà´Â≠óÊØçÊï∞</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${avgConfidence}%</div>
                        <div class="stat-label">Âπ≥ÂùáÁΩÆ‰ø°Â∫¶</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${recognitionRate}%</div>
                        <div class="stat-label">ËØÜÂà´Áéá</div>
                    </div>
                </div>
                ${recognizedWords.length > 0 ? `
                <div style="margin-top: 15px;">
                    <strong>ËØÜÂà´Âà∞ÁöÑÂÆåÊï¥ÂçïËØçÔºö</strong>
                    <div style="margin-top: 5px;">
                        ${recognizedWords.map(word => `
                            <span style="display: inline-block; padding: 5px 10px; margin: 3px; background: #4CAF50; color: white; border-radius: 4px; font-weight: bold;">
                                ${word}
                            </span>
                        `).join('')}
                    </div>
                </div>
                ` : ''}
                ${Object.keys(letterCounts).length > 0 ? `
                <div style="margin-top: 15px;">
                    <strong>Â≠óÊØçÂàÜÂ∏ÉÔºö</strong>
                    <div style="margin-top: 5px; font-family: monospace;">
                        ${Object.entries(letterCounts)
                            .sort(([a], [b]) => a.localeCompare(b))
                            .map(([letter, count]) => `${letter}:${count}`)
                            .join(' | ')}
                    </div>
                </div>
                ` : ''}
            `;
            
            container.appendChild(summaryDiv);
        }
    </script>
</body>
</html>