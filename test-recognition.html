<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wordle è¯†åˆ«æµ‹è¯•</title>
    <script src='https://unpkg.com/tesseract.js@4.1.1/dist/tesseract.min.js'></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            padding: 20px;
            background: #f5f5f5;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #333;
        }
        
        .upload-area {
            background: white;
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .upload-area:hover {
            border-color: #4CAF50;
            background: #f9f9f9;
        }
        
        .upload-area.dragover {
            border-color: #4CAF50;
            background: #e8f5e9;
        }
        
        #fileInput {
            display: none;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .panel {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .panel h2 {
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        }
        
        #originalCanvas, #processedCanvas {
            max-width: 100%;
            border: 1px solid #ddd;
            display: block;
            margin: 0 auto;
        }
        
        .cells-grid {
            display: grid;
            gap: 5px;
            margin-top: 20px;
        }
        
        .cell-analysis {
            border: 1px solid #ddd;
            padding: 10px;
            background: white;
            border-radius: 4px;
        }
        
        .cell-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .cell-preview {
            width: 60px;
            height: 60px;
            border: 1px solid #ccc;
            display: inline-block;
            margin-right: 10px;
        }
        
        .cell-info {
            flex: 1;
        }
        
        .color-box {
            width: 30px;
            height: 30px;
            border: 1px solid #333;
            display: inline-block;
            margin-right: 10px;
            vertical-align: middle;
        }
        
        .state-badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            color: white;
        }
        
        .state-correct { background: #6aaa64; }
        .state-present { background: #c9b458; }
        .state-absent { background: #787c7e; }
        .state-empty { background: #d3d6da; color: #333; }
        
        .stats {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
            margin-top: 20px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .controls {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: white;
            padding: 10px;
            border-radius: 4px;
        }
        
        label {
            font-weight: bold;
            color: #555;
        }
        
        input[type="number"] {
            width: 60px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        
        button {
            padding: 8px 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        
        button:hover {
            background: #45a049;
        }
        
        .game-state {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .wordle-row {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
        }
        
        .wordle-cell {
            width: 50px;
            height: 50px;
            border: 2px solid #d3d6da;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            text-transform: uppercase;
            position: relative;
        }
        
        .wordle-cell.correct {
            background: #6aaa64;
            border-color: #6aaa64;
            color: white;
        }
        
        .wordle-cell.present {
            background: #c9b458;
            border-color: #c9b458;
            color: white;
        }
        
        .wordle-cell.absent {
            background: #787c7e;
            border-color: #787c7e;
            color: white;
        }
        
        .confidence-badge {
            position: absolute;
            bottom: -8px;
            right: -8px;
            background: #2196F3;
            color: white;
            font-size: 10px;
            padding: 2px 4px;
            border-radius: 10px;
            font-weight: normal;
        }
        
        .recognition-summary {
            margin-top: 20px;
            padding: 15px;
            background: #f0f8ff;
            border-radius: 8px;
            border: 1px solid #4CAF50;
        }
        
        .summary-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 10px;
        }
        
        .stat-card {
            text-align: center;
            padding: 10px;
            background: white;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
        
        /* OCRè°ƒè¯•é¢æ¿æ ·å¼ */
        #ocrDebugPanel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 800px;
            background: white;
            border: 2px solid #4CAF50;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 1000;
            display: none;
        }
        
        #ocrDebugPanel.active {
            display: block;
        }
        
        .debug-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }
        
        .debug-close {
            background: #f44336;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .debug-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }
        
        .debug-stage {
            text-align: center;
        }
        
        .debug-stage h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #333;
        }
        
        .debug-canvas {
            border: 1px solid #ccc;
            background: #f9f9f9;
            max-width: 100%;
            height: 100px;
            object-fit: contain;
        }
        
        .debug-info {
            margin-top: 10px;
            font-size: 12px;
            color: #666;
        }
        
        .confidence-chart {
            margin-top: 15px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 4px;
        }
        
        .confidence-bar {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 12px;
        }
        
        .confidence-bar-label {
            width: 30px;
            font-weight: bold;
        }
        
        .confidence-bar-track {
            flex: 1;
            height: 20px;
            background: #ddd;
            border-radius: 3px;
            margin: 0 10px;
            position: relative;
            overflow: hidden;
        }
        
        .confidence-bar-fill {
            height: 100%;
            background: #4CAF50;
            transition: width 0.3s;
        }
        
        .confidence-bar-value {
            width: 50px;
            text-align: right;
        }
        
        .cell-analysis {
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .cell-analysis:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¯ Wordle è¯†åˆ«æµ‹è¯•å·¥å…·</h1>
        
        <!-- OCRè°ƒè¯•é¢æ¿ -->
        <div id="ocrDebugPanel">
            <div class="debug-header">
                <h3>ğŸ” OCRè¯†åˆ«è°ƒè¯•</h3>
                <button class="debug-close" onclick="closeDebugPanel()">âœ•</button>
            </div>
            <div class="debug-content" id="debugContent">
                <!-- åŠ¨æ€ç”Ÿæˆçš„è°ƒè¯•å†…å®¹ -->
            </div>
            <div class="confidence-chart" id="confidenceChart">
                <!-- ç½®ä¿¡åº¦å›¾è¡¨ -->
            </div>
        </div>
        
        <div class="upload-area" id="uploadArea">
            <p>ğŸ“· ç‚¹å‡»ä¸Šä¼ å›¾ç‰‡æˆ–æ‹–æ‹½å›¾ç‰‡åˆ°è¿™é‡Œ</p>
            <p style="margin-top: 10px; color: #666; font-size: 14px;">æ”¯æŒ PNG, JPG, JPEG æ ¼å¼</p>
            <input type="file" id="fileInput" accept="image/*">
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>é…è‰²æ–¹æ¡ˆï¼š</label>
                <select id="colorSchemeSelect" onchange="reprocess()" style="padding: 5px; border: 1px solid #ccc; border-radius: 4px; min-width: 180px;">
                    <option value="wordle2.io">wordle2.io</option>
                    <option value="lessgames.com">lessgames.com/wordless</option>
                    <option value="auto" selected>è‡ªåŠ¨æ£€æµ‹</option>
                </select>
            </div>
            <div class="control-group">
                <label>åˆ—æ•°ï¼š</label>
                <input type="number" id="colsInput" value="5" min="3" max="11">
            </div>
            <div class="control-group">
                <label>è¡Œæ•°ï¼š</label>
                <input type="number" id="rowsInput" value="6" min="1" max="10">
            </div>
            <div class="control-group">
                <label>æ ¼å­é—´éš™(%)ï¼š</label>
                <input type="number" id="gapInput" value="8" min="0" max="20" step="1">
            </div>
            <button onclick="reprocess()">é‡æ–°å¤„ç†</button>
        </div>
        
        <div class="main-content">
            <div class="panel">
                <h2>ğŸ“¥ åŸå§‹å›¾ç‰‡</h2>
                <canvas id="originalCanvas"></canvas>
                <div id="debugInfo" style="background: #fffbf0; border: 1px solid #f0ad4e; padding: 10px; margin: 10px 0; border-radius: 4px; font-size: 12px; display: none;">
                    <strong>è°ƒè¯•ä¿¡æ¯ï¼š</strong>
                    <ul style="margin: 5px 0;">
                        <li>ğŸ”´ çº¢æ¡†ï¼šæ£€æµ‹åˆ°çš„æ¸¸æˆåŒºåŸŸè¾¹ç•Œ</li>
                        <li>ğŸ”µ è“æ¡†ï¼šæ¯ä¸ªæ ¼å­çš„è¯†åˆ«åŒºåŸŸ</li>
                    </ul>
                </div>
                <div class="stats">
                    <div class="stat-row">
                        <span>å›¾ç‰‡å°ºå¯¸ï¼š</span>
                        <span id="imageSize">-</span>
                    </div>
                    <div class="stat-row">
                        <span>å®½é«˜æ¯”ï¼š</span>
                        <span id="aspectRatio">-</span>
                    </div>
                    <div class="stat-row">
                        <span>è‡ªåŠ¨æ£€æµ‹åˆ—æ•°ï¼š</span>
                        <span id="detectedCols">-</span>
                    </div>
                    <div class="stat-row">
                        <span>å½“å‰é…è‰²æ–¹æ¡ˆï¼š</span>
                        <span id="currentScheme">-</span>
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <h2>ğŸ¯ è¯†åˆ«ç»“æœ</h2>
                <div id="gameState" class="game-state"></div>
            </div>
        </div>
        
        <div class="panel">
            <h2>ğŸ”¬ æ ¼å­åˆ†æ</h2>
            <div id="cellsAnalysis" class="cells-grid"></div>
        </div>
    </div>
    
    <script>
        let currentImage = null;
        
        // æ–‡ä»¶ä¸Šä¼ å¤„ç†
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        
        uploadArea.addEventListener('click', () => fileInput.click());
        
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                handleFile(file);
            }
        });
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleFile(file);
            }
        });
        
        function handleFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = async () => {
                    currentImage = img;
                    await processImage(img);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        async function reprocess() {
            if (currentImage) {
                await processImage(currentImage);
            }
        }
        
        async function processImage(img) {
            const canvas = document.getElementById('originalCanvas');
            const ctx = canvas.getContext('2d');
            
            // æ˜¾ç¤ºåŸå›¾
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            // æ˜¾ç¤ºå›¾ç‰‡ä¿¡æ¯
            document.getElementById('imageSize').textContent = `${img.width} x ${img.height}`;
            const aspectRatio = img.width / img.height;
            document.getElementById('aspectRatio').textContent = aspectRatio.toFixed(2);
            
            // æ˜¾ç¤ºå½“å‰é…è‰²æ–¹æ¡ˆ
            const schemeSelect = document.getElementById('colorSchemeSelect');
            const scheme = schemeSelect ? schemeSelect.value : 'auto';
            document.getElementById('currentScheme').textContent = scheme;
            
            // è‡ªåŠ¨æ£€æµ‹åˆ—æ•°
            let detectedCols = 5;
            if (aspectRatio > 0.95) {
                detectedCols = Math.round(aspectRatio * 6);
                detectedCols = Math.min(Math.max(detectedCols, 5), 11);
            }
            document.getElementById('detectedCols').textContent = detectedCols;
            document.getElementById('colsInput').value = detectedCols;
            
            // åˆ†ææ ¼å­
            await analyzeCells(img);
        }
        
        async function analyzeCells(img) {
            const cols = parseInt(document.getElementById('colsInput').value);
            const rows = parseInt(document.getElementById('rowsInput').value);
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            // å…ˆæ‰¾åˆ°æ¸¸æˆæ¿çš„å®é™…è¾¹ç•Œ
            const gameBounds = findGameBoard(ctx, img.width, img.height);
            console.log('æ£€æµ‹åˆ°çš„æ¸¸æˆè¾¹ç•Œ:', gameBounds);
            
            // æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
            document.getElementById('debugInfo').style.display = 'block';
            
            // åœ¨åŸå›¾ä¸Šç»˜åˆ¶è¾¹ç•Œæ¡†ï¼ˆç”¨äºè°ƒè¯•ï¼‰
            const originalCanvas = document.getElementById('originalCanvas');
            const originalCtx = originalCanvas.getContext('2d');
            
            // é‡æ–°ç»˜åˆ¶åŸå›¾
            originalCanvas.width = img.width;
            originalCanvas.height = img.height;
            originalCtx.drawImage(img, 0, 0);
            
            // ç»˜åˆ¶æ¸¸æˆè¾¹ç•Œ
            originalCtx.strokeStyle = 'red';
            originalCtx.lineWidth = 2;
            originalCtx.strokeRect(gameBounds.x, gameBounds.y, gameBounds.width, gameBounds.height);
            
            // è®¡ç®—æ¯ä¸ªæ ¼å­çš„å¤§å°ï¼ˆè€ƒè™‘æ ¼å­é—´çš„é—´éš™ï¼‰
            const cellWidth = gameBounds.width / cols;
            const cellHeight = gameBounds.height / rows;
            
            // è·å–ç”¨æˆ·è®¾ç½®çš„æ ¼å­é—´éš™
            const gapRatio = parseInt(document.getElementById('gapInput').value) / 100;
            const actualCellWidth = cellWidth * (1 - gapRatio);
            const actualCellHeight = cellHeight * (1 - gapRatio);
            const gapX = cellWidth * gapRatio / 2;
            const gapY = cellHeight * gapRatio / 2;
            
            const cellsDiv = document.getElementById('cellsAnalysis');
            cellsDiv.innerHTML = '';
            cellsDiv.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            
            const gameStateDiv = document.getElementById('gameState');
            gameStateDiv.innerHTML = '';
            
            const gameRows = [];
            
            for (let row = 0; row < rows; row++) {
                const gameRow = [];
                for (let col = 0; col < cols; col++) {
                    // è®¡ç®—æ ¼å­çš„å®é™…ä½ç½®ï¼ˆè€ƒè™‘é—´éš™ï¼‰
                    const x = gameBounds.x + col * cellWidth + gapX;
                    const y = gameBounds.y + row * cellHeight + gapY;
                    
                    // åœ¨åŸå›¾ä¸Šç»˜åˆ¶æ ¼å­æ¡†ï¼ˆç”¨äºè°ƒè¯•ï¼‰
                    originalCtx.strokeStyle = 'blue';
                    originalCtx.lineWidth = 1;
                    originalCtx.strokeRect(x, y, actualCellWidth, actualCellHeight);
                    
                    // è·å–æ ¼å­å›¾åƒæ•°æ®
                    // ç¡®ä¿åæ ‡å’Œå°ºå¯¸åœ¨å›¾åƒèŒƒå›´å†…
                    const cellX = Math.max(0, Math.floor(x));
                    const cellY = Math.max(0, Math.floor(y));
                    const cellW = Math.min(Math.floor(actualCellWidth), img.width - cellX);
                    const cellH = Math.min(Math.floor(actualCellHeight), img.height - cellY);
                    const cellData = ctx.getImageData(cellX, cellY, cellW, cellH);
                    
                    // åˆ†ææ ¼å­
                    const analysis = analyzeCell(cellData, row, col);
                    gameRow.push(analysis);
                }
                gameRows.push(gameRow);
            }
            
            // å¼‚æ­¥è¯†åˆ«æ‰€æœ‰æœ‰å­—æ¯çš„æ ¼å­
            const ocrPromises = [];
            for (let row = 0; row < gameRows.length; row++) {
                for (let col = 0; col < gameRows[row].length; col++) {
                    const cell = gameRows[row][col];
                    if (cell.hasLetter && cell.imageData) {
                        ocrPromises.push(
                            recognizeLetter(cell.imageData).then(result => {
                                cell.letter = result.letter;
                                cell.confidence = result.confidence;
                                delete cell.imageData; // æ¸…ç†ä¸éœ€è¦çš„æ•°æ®
                                return cell;
                            })
                        );
                    }
                }
            }
            
            // ç­‰å¾…æ‰€æœ‰OCRå®Œæˆ
            await Promise.all(ocrPromises);
            
            // åˆ›å»ºUIæ˜¾ç¤º
            cellsDiv.innerHTML = '';
            cellsDiv.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            
            for (let row = 0; row < gameRows.length; row++) {
                for (let col = 0; col < gameRows[row].length; col++) {
                    const analysis = gameRows[row][col];
                    const cellX = gameBounds.x + col * cellWidth + gapX;
                    const cellY = gameBounds.y + row * cellHeight + gapY;
                    const cellData = ctx.getImageData(
                        Math.max(0, Math.floor(cellX)),
                        Math.max(0, Math.floor(cellY)),
                        Math.min(Math.floor(actualCellWidth), img.width - Math.floor(cellX)),
                        Math.min(Math.floor(actualCellHeight), img.height - Math.floor(cellY))
                    );
                    const cellDiv = createCellAnalysisUI(analysis, cellData);
                    cellsDiv.appendChild(cellDiv);
                }
            }
            
            // æ˜¾ç¤ºæ¸¸æˆçŠ¶æ€
            displayGameState(gameRows, gameStateDiv);
        }
        
        function findGameBoard(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            // ä½¿ç”¨æ›´æ™ºèƒ½çš„æ–¹æ³•æ‰¾åˆ°æ¸¸æˆæ¿
            // 1. å…ˆæ‰¾åˆ°æ‰€æœ‰æ ¼å­çš„è¾¹ç¼˜
            const edges = detectEdges(imageData);
            
            // 2. æ‰¾åˆ°æ°´å¹³å’Œå‚ç›´çº¿æ¡
            const horizontalLines = findHorizontalLines(edges, width, height);
            const verticalLines = findVerticalLines(edges, width, height);
            
            console.log(`æ‰¾åˆ° ${horizontalLines.length} æ¡æ°´å¹³çº¿, ${verticalLines.length} æ¡å‚ç›´çº¿`);
            
            // 3. å¦‚æœæ‰¾åˆ°äº†è¶³å¤Ÿçš„çº¿æ¡ï¼Œä½¿ç”¨å®ƒä»¬ç¡®å®šè¾¹ç•Œ
            if (horizontalLines.length >= 2 && verticalLines.length >= 2) {
                const minY = Math.min(...horizontalLines);
                const maxY = Math.max(...horizontalLines);
                const minX = Math.min(...verticalLines);
                const maxX = Math.max(...verticalLines);
                
                return {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            }
            
            // 4. å¦åˆ™ä½¿ç”¨åŸå§‹æ–¹æ³•ï¼ˆæ‰¾éç™½è‰²åŒºåŸŸï¼‰
            let minX = width, maxX = 0;
            let minY = height, maxY = 0;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    
                    // å¦‚æœä¸æ˜¯ç™½è‰²æˆ–æ¥è¿‘ç™½è‰²çš„èƒŒæ™¯
                    if (r < 240 || g < 240 || b < 240) {
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                    }
                }
            }
            
            // æ·»åŠ ä¸€äº›è¾¹è·
            const padding = 5;
            minX = Math.max(0, minX - padding);
            minY = Math.max(0, minY - padding);
            maxX = Math.min(width - 1, maxX + padding);
            maxY = Math.min(height - 1, maxY + padding);
            
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }
        
        // ç®€å•çš„è¾¹ç¼˜æ£€æµ‹
        function detectEdges(imageData) {
            const { width, height, data } = imageData;
            const edges = new Uint8ClampedArray(width * height);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // è®¡ç®—æ°´å¹³å’Œå‚ç›´æ¢¯åº¦
                    const gx = Math.abs(data[idx] - data[idx + 4]) + 
                               Math.abs(data[idx + 1] - data[idx + 5]) + 
                               Math.abs(data[idx + 2] - data[idx + 6]);
                    
                    const gy = Math.abs(data[idx] - data[idx + width * 4]) + 
                               Math.abs(data[idx + 1] - data[idx + width * 4 + 1]) + 
                               Math.abs(data[idx + 2] - data[idx + width * 4 + 2]);
                    
                    edges[y * width + x] = (gx + gy) > 50 ? 255 : 0;
                }
            }
            
            return edges;
        }
        
        // æ‰¾æ°´å¹³çº¿
        function findHorizontalLines(edges, width, height) {
            const lines = [];
            const threshold = width * 0.3; // è‡³å°‘30%çš„å®½åº¦æ‰ç®—ä¸€æ¡çº¿
            
            for (let y = 0; y < height; y++) {
                let count = 0;
                for (let x = 0; x < width; x++) {
                    if (edges[y * width + x] > 0) count++;
                }
                if (count > threshold) {
                    lines.push(y);
                }
            }
            
            // åˆå¹¶ç›¸è¿‘çš„çº¿
            return mergeCloseLines(lines, 10);
        }
        
        // æ‰¾å‚ç›´çº¿
        function findVerticalLines(edges, width, height) {
            const lines = [];
            const threshold = height * 0.3; // è‡³å°‘30%çš„é«˜åº¦æ‰ç®—ä¸€æ¡çº¿
            
            for (let x = 0; x < width; x++) {
                let count = 0;
                for (let y = 0; y < height; y++) {
                    if (edges[y * width + x] > 0) count++;
                }
                if (count > threshold) {
                    lines.push(x);
                }
            }
            
            // åˆå¹¶ç›¸è¿‘çš„çº¿
            return mergeCloseLines(lines, 10);
        }
        
        // åˆå¹¶ç›¸è¿‘çš„çº¿æ¡
        function mergeCloseLines(lines, threshold) {
            if (lines.length === 0) return [];
            
            lines.sort((a, b) => a - b);
            const merged = [lines[0]];
            
            for (let i = 1; i < lines.length; i++) {
                if (lines[i] - merged[merged.length - 1] > threshold) {
                    merged.push(lines[i]);
                }
            }
            
            return merged;
        }
        
        function analyzeCell(imageData, row, col) {
            // è®¡ç®—å¹³å‡é¢œè‰²
            const avgColor = getAverageColor(imageData);
            
            // å…ˆåˆæ­¥åˆ†ç±»é¢œè‰²
            let state = classifyColor(avgColor);
            
            // æ£€æµ‹æ˜¯å¦æœ‰å­—æ¯
            const hasLetter = detectLetterPresence(imageData);
            
            // æ ¹æ®é…è‰²æ–¹æ¡ˆå†³å®šæ˜¯å¦éœ€è¦å­—æ¯æ£€æµ‹æ¥ç»†åŒ–åˆ†ç±»
            const schemeSelect = document.getElementById('colorSchemeSelect');
            const scheme = schemeSelect ? schemeSelect.value : 'auto';
            
            if (scheme === 'auto') {
                // è‡ªåŠ¨æ¨¡å¼ï¼šä½¿ç”¨å­—æ¯æ£€æµ‹ç»“æœæ¥ç»†åŒ–é¢œè‰²åˆ†ç±»
                if (state === 'absent' || state === 'empty') {
                    if (hasLetter) {
                        state = 'absent';
                    } else {
                        state = 'empty';
                    }
                }
            } else if (COLOR_SCHEMES[scheme]) {
                // ç‰¹å®šé…è‰²æ–¹æ¡ˆæ¨¡å¼ï¼šå¯¹äºemptyå’Œabsentçš„åŒºåˆ†æ›´ä¾èµ–é¢œè‰²
                // ä½†ä»ç„¶å¯ä»¥ç”¨å­—æ¯æ£€æµ‹ä½œä¸ºè¾…åŠ©éªŒè¯
                if (state === 'empty' && hasLetter) {
                    // å¦‚æœé¢œè‰²åˆ¤æ–­ä¸ºemptyä½†æ£€æµ‹åˆ°å­—æ¯ï¼Œå¯èƒ½æ˜¯è¯¯åˆ¤
                    // é‡æ–°æ£€æŸ¥æ˜¯å¦æ›´æ¥è¿‘absent
                    const colors = COLOR_SCHEMES[scheme];
                    const distToEmpty = colorDistance(avgColor, colors.empty);
                    const distToAbsent = colorDistance(avgColor, colors.absent);
                    if (distToAbsent < distToEmpty * 1.5) {
                        state = 'absent';
                    }
                }
            }
            // å¯¹äº correct å’Œ presentï¼Œä¿æŒåŸåˆ¤æ–­ï¼ˆè¿™äº›æ ¼å­è‚¯å®šæœ‰å­—æ¯ï¼‰
            
            // å°è¯•è¯†åˆ«å­—æ¯
            let letter = '';
            let confidence = 0;
            if (hasLetter) {
                // æ³¨æ„ï¼šrecognizeLetter ç°åœ¨æ˜¯å¼‚æ­¥çš„
                // è¿™é‡Œå…ˆè¿”å›ç©ºå€¼ï¼Œç¨åä¼šåœ¨å¼‚æ­¥å¤„ç†ä¸­æ›´æ–°
                return {
                    row,
                    col,
                    avgColor,
                    state,
                    hasLetter,
                    letter,
                    confidence,
                    imageData // ä¿å­˜imageDataä¾›åç»­OCRä½¿ç”¨
                };
            }
            
            return {
                row,
                col,
                avgColor,
                state,
                hasLetter,
                letter,
                confidence
            };
        }
        
        function getAverageColor(imageData) {
            const data = imageData.data;
            let r = 0, g = 0, b = 0;
            let count = 0;
            
            // é‡‡æ ·æ•´ä¸ªæ ¼å­ï¼Œä½†è·³è¿‡è¾¹ç¼˜ï¼ˆå¯èƒ½æœ‰è¾¹æ¡†ï¼‰
            const margin = Math.floor(Math.min(imageData.width, imageData.height) * 0.1);
            const startX = margin;
            const endX = imageData.width - margin;
            const startY = margin;
            const endY = imageData.height - margin;
            
            // æ¯éš”å‡ ä¸ªåƒç´ é‡‡æ ·ä¸€æ¬¡ï¼ŒåŠ å¿«é€Ÿåº¦
            const step = Math.max(1, Math.floor(Math.min(imageData.width, imageData.height) / 20));
            
            for (let y = startY; y < endY; y += step) {
                for (let x = startX; x < endX; x += step) {
                    const idx = (y * imageData.width + x) * 4;
                    r += data[idx];
                    g += data[idx + 1];
                    b += data[idx + 2];
                    count++;
                }
            }
            
            if (count === 0) {
                // å¦‚æœæ²¡æœ‰é‡‡æ ·åˆ°ä»»ä½•ç‚¹ï¼Œè¿”å›é»˜è®¤ç™½è‰²
                return { r: 255, g: 255, b: 255 };
            }
            
            return {
                r: Math.round(r / count),
                g: Math.round(g / count),
                b: Math.round(b / count)
            };
        }
        
        // å®šä¹‰ä¸åŒç½‘ç«™çš„é…è‰²æ–¹æ¡ˆ
        const COLOR_SCHEMES = {
            'wordle2.io': {
                // wordle2.ioé…è‰²
                empty: { r: 250, g: 251, b: 255 },      // #fafbff
                absent: { r: 155, g: 164, b: 187 },     // #9ba4bb
                present: { r: 236, g: 188, b: 67 },     // #ecbc43
                correct: { r: 122, g: 172, b: 80 },     // #7aac50
                tolerance: 30  // é¢œè‰²å®¹å·®
            },
            'lessgames.com': {
                // lessgames.com/wordlessé…è‰²
                empty: { r: 43, g: 46, b: 47 },         // #2b2e2f
                absent: { r: 109, g: 118, b: 124 },     // #6d767c
                present: { r: 211, g: 187, b: 51 },     // #d3bb33
                correct: { r: 96, g: 170, b: 51 },      // #60aa33
                tolerance: 30
            },
            'auto': {
                // è‡ªåŠ¨æ£€æµ‹æ¨¡å¼ï¼Œä½¿ç”¨åŸæ¥çš„é€šç”¨ç®—æ³•
                tolerance: 40
            }
        };
        
        // è®¡ç®—ä¸¤ä¸ªé¢œè‰²ä¹‹é—´çš„æ¬§æ°è·ç¦»
        function colorDistance(c1, c2) {
            return Math.sqrt(
                Math.pow(c1.r - c2.r, 2) +
                Math.pow(c1.g - c2.g, 2) +
                Math.pow(c1.b - c2.b, 2)
            );
        }
        
        function classifyColor(color) {
            const { r, g, b } = color;
            const schemeSelect = document.getElementById('colorSchemeSelect');
            const scheme = schemeSelect ? schemeSelect.value : 'auto';
            
            // å¦‚æœé€‰æ‹©äº†ç‰¹å®šçš„é…è‰²æ–¹æ¡ˆ
            if (scheme !== 'auto' && COLOR_SCHEMES[scheme]) {
                const colors = COLOR_SCHEMES[scheme];
                const tolerance = colors.tolerance || 30;
                
                // è®¡ç®—ä¸æ¯ç§çŠ¶æ€é¢œè‰²çš„è·ç¦»
                const distances = {
                    empty: colorDistance(color, colors.empty),
                    absent: colorDistance(color, colors.absent),
                    present: colorDistance(color, colors.present),
                    correct: colorDistance(color, colors.correct)
                };
                
                // æ‰¾å‡ºæœ€æ¥è¿‘çš„é¢œè‰²
                let minDistance = Infinity;
                let bestMatch = 'empty';
                
                for (const [state, distance] of Object.entries(distances)) {
                    if (distance < minDistance) {
                        minDistance = distance;
                        bestMatch = state;
                    }
                }
                
                // å¦‚æœæœ€å°è·ç¦»åœ¨å®¹å·®èŒƒå›´å†…ï¼Œè¿”å›åŒ¹é…çš„çŠ¶æ€
                if (minDistance <= tolerance) {
                    return bestMatch;
                }
                
                // å¦‚æœæ²¡æœ‰å¥½çš„åŒ¹é…ï¼Œæ ¹æ®äº®åº¦åšåŸºæœ¬åˆ¤æ–­
                const brightness = (r + g + b) / 3;
                if (brightness > 200) return 'empty';
                if (brightness < 100) return 'absent';
                return 'empty';
            }
            
            // è‡ªåŠ¨æ£€æµ‹æ¨¡å¼ - ä½¿ç”¨åŸæ¥çš„é€šç”¨ç®—æ³•
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const delta = max - min;
            
            // ç»¿è‰² - correct
            if (g > r && g > b && g > 100 && delta > 30) {
                if (r < g * 0.85 && b < g * 0.85) {
                    return 'correct';
                }
            }
            
            // é»„è‰² - present
            if (r > 150 && g > 100 && delta > 30) {
                if (b < r * 0.7 && b < g * 0.7) {
                    return 'present';
                }
            }
            
            // ç°è‰²ç³»
            if (delta < 40) {
                if (max > 210) return 'empty';
                if (max < 120) return 'absent';
                return 'absent';
            }
            
            return 'absent';
        }
        
        function detectLetterPresence(imageData) {
            const { width, height, data } = imageData;
            
            // è®¡ç®—æ•´ä¸ªæ ¼å­çš„é¢œè‰²ç»Ÿè®¡
            const colorStats = analyzeColorDistribution(imageData);
            
            // åˆ¤æ–­æ˜¯å¦æœ‰å­—æ¯çš„å¤šç§ç­–ç•¥
            
            // ç­–ç•¥1ï¼šé¢œè‰²åˆ†å¸ƒçš„æ ‡å‡†å·®ï¼ˆæœ‰å­—æ¯çš„æ ¼å­é¢œè‰²å˜åŒ–æ›´å¤§ï¼‰
            // é™ä½é˜ˆå€¼ï¼Œè®©æ£€æµ‹æ›´æ•æ„Ÿ
            if (colorStats.stdDev > 20) {
                return true;
            }
            
            // ç­–ç•¥2ï¼šæ£€æµ‹æ˜¯å¦æœ‰æ˜æ˜¾çš„åŒå³°åˆ†å¸ƒï¼ˆèƒŒæ™¯è‰²å’Œæ–‡å­—è‰²ï¼‰
            if (colorStats.hasBimodal) {
                return true;
            }
            
            // ç­–ç•¥3ï¼šè¾¹ç¼˜æ£€æµ‹ï¼ˆå­—æ¯ä¼šäº§ç”Ÿæ›´å¤šè¾¹ç¼˜ï¼‰
            const edgeCount = detectEdgePixels(imageData);
            const edgeRatio = edgeCount / (width * height);
            if (edgeRatio > 0.02) { // é™ä½åˆ°2%ï¼Œæ›´å®¹æ˜“æ£€æµ‹åˆ°å­—æ¯
                return true;
            }
            
            // ç­–ç•¥4ï¼šå¯¹äºæ·±è‰²èƒŒæ™¯ï¼ˆabsentæ ¼å­ï¼‰ï¼Œç‰¹åˆ«æ£€æµ‹äº®è‰²åƒç´ 
            if (colorStats.avgBrightness < 130) { // æé«˜é˜ˆå€¼åˆ°130
                // æ·±è‰²èƒŒæ™¯ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„äº®è‰²åƒç´ ï¼ˆå¯èƒ½æ˜¯ç™½è‰²å­—æ¯ï¼‰
                if (colorStats.brightPixelRatio > 0.03) { // é™ä½åˆ°3%
                    return true;
                }
            }
            
            // ç­–ç•¥5ï¼šå¯¹äºä¸­ç­‰äº®åº¦ï¼ˆå¯èƒ½æ˜¯ç°è‰²absentï¼‰ï¼Œæ£€æŸ¥å¯¹æ¯”åº¦
            if (colorStats.avgBrightness >= 70 && colorStats.avgBrightness <= 140) {
                // ç°è‰²èƒŒæ™¯ï¼Œå¦‚æœæœ‰ä¸€å®šæ¯”ä¾‹çš„ç‰¹åˆ«äº®æˆ–ç‰¹åˆ«æš—çš„åƒç´ ï¼Œå¯èƒ½æœ‰å­—æ¯
                if (colorStats.brightPixelRatio > 0.02 || colorStats.darkPixelRatio > 0.02) {
                    return true;
                }
            }
            
            return false;
        }
        
        // åˆ†æé¢œè‰²åˆ†å¸ƒ
        function analyzeColorDistribution(imageData) {
            const { width, height, data } = imageData;
            const brightnesses = [];
            let sum = 0;
            let brightCount = 0;
            let darkCount = 0;
            
            // æ”¶é›†æ‰€æœ‰åƒç´ çš„äº®åº¦å€¼
            for (let i = 0; i < data.length; i += 4) {
                const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                brightnesses.push(brightness);
                sum += brightness;
                
                if (brightness > 200) brightCount++;
                if (brightness < 50) darkCount++;
            }
            
            const avg = sum / brightnesses.length;
            
            // è®¡ç®—æ ‡å‡†å·®
            let variance = 0;
            for (const b of brightnesses) {
                variance += Math.pow(b - avg, 2);
            }
            const stdDev = Math.sqrt(variance / brightnesses.length);
            
            // æ£€æµ‹åŒå³°åˆ†å¸ƒï¼ˆç®€å•ç‰ˆæœ¬ï¼šæ£€æŸ¥æ˜¯å¦åŒæ—¶æœ‰å¾ˆå¤šäº®åƒç´ å’Œæš—åƒç´ ï¼‰
            // é™ä½é˜ˆå€¼åˆ°5%ï¼Œè®©æ£€æµ‹æ›´æ•æ„Ÿ
            const hasBimodal = (brightCount > brightnesses.length * 0.05 && 
                               darkCount > brightnesses.length * 0.05);
            
            return {
                avgBrightness: avg,
                stdDev: stdDev,
                hasBimodal: hasBimodal,
                brightPixelRatio: brightCount / brightnesses.length,
                darkPixelRatio: darkCount / brightnesses.length
            };
        }
        
        // è¾¹ç¼˜æ£€æµ‹
        function detectEdgePixels(imageData) {
            const { width, height, data } = imageData;
            let edgeCount = 0;
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    const center = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                    
                    // æ£€æŸ¥æ°´å¹³å’Œå‚ç›´æ–¹å‘çš„æ¢¯åº¦
                    const rightIdx = idx + 4;
                    const bottomIdx = idx + width * 4;
                    
                    const right = (data[rightIdx] + data[rightIdx + 1] + data[rightIdx + 2]) / 3;
                    const bottom = (data[bottomIdx] + data[bottomIdx + 1] + data[bottomIdx + 2]) / 3;
                    
                    const gradX = Math.abs(center - right);
                    const gradY = Math.abs(center - bottom);
                    
                    // å¦‚æœæ¢¯åº¦è¶³å¤Ÿå¤§ï¼Œè®¤ä¸ºæ˜¯è¾¹ç¼˜
                    // é™ä½é˜ˆå€¼åˆ°20ï¼Œè®©æ£€æµ‹æ›´æ•æ„Ÿ
                    if (gradX > 20 || gradY > 20) {
                        edgeCount++;
                    }
                }
            }
            
            return edgeCount;
        }
        
        // å­—æ¯è¯†åˆ«å‡½æ•°ï¼ˆå¢å¼ºç‰ˆï¼Œè¿”å›è°ƒè¯•ä¿¡æ¯ï¼‰
        async function recognizeLetter(imageData, returnDebugInfo = false) {
            const debugInfo = {
                stages: [],
                confidences: {}
            };
            
            // åˆ›å»ºä¸´æ—¶canvas
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = imageData.width;
            tempCanvas.height = imageData.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // ä¿å­˜åŸå§‹å›¾åƒ
            if (returnDebugInfo) {
                const originalCanvas = document.createElement('canvas');
                originalCanvas.width = imageData.width;
                originalCanvas.height = imageData.height;
                const originalCtx = originalCanvas.getContext('2d');
                originalCtx.putImageData(imageData, 0, 0);
                debugInfo.stages.push({
                    name: 'åŸå§‹å›¾åƒ',
                    canvas: originalCanvas,
                    dataUrl: originalCanvas.toDataURL()
                });
            }
            
            // é¢„å¤„ç†ï¼šå¢å¼ºå¯¹æ¯”åº¦
            const processedData = preprocessForOCR(imageData);
            tempCtx.putImageData(processedData, 0, 0);
            
            if (returnDebugInfo) {
                const processedCanvas = document.createElement('canvas');
                processedCanvas.width = imageData.width;
                processedCanvas.height = imageData.height;
                const processedCtx = processedCanvas.getContext('2d');
                processedCtx.putImageData(processedData, 0, 0);
                debugInfo.stages.push({
                    name: 'é¢„å¤„ç†å',
                    canvas: processedCanvas,
                    dataUrl: processedCanvas.toDataURL()
                });
            }
            
            try {
                // ä¼˜åŒ–1ï¼šé€‚åº¦ç¼©æ”¾ï¼ˆTesseractæœ€ä½³DPIçº¦ä¸º300ï¼‰
                // å¦‚æœå›¾åƒå¤ªå°ï¼Œæ”¾å¤§åˆ°çº¦100åƒç´ ï¼›å¦åˆ™ä¿æŒåŸæ ·æˆ–é€‚åº¦æ”¾å¤§
                let scaleFactor = 1;
                const minSize = 50; // æœ€å°è¾¹é•¿ç›®æ ‡
                const maxSize = 150; // æœ€å¤§è¾¹é•¿ç›®æ ‡
                const currentMinSize = Math.min(imageData.width, imageData.height);
                
                if (currentMinSize < minSize) {
                    scaleFactor = minSize / currentMinSize;
                } else if (currentMinSize > maxSize) {
                    scaleFactor = maxSize / currentMinSize;
                }
                
                // é™åˆ¶ç¼©æ”¾å› å­åœ¨åˆç†èŒƒå›´å†…
                scaleFactor = Math.max(1, Math.min(3, scaleFactor));
                
                const scaledCanvas = document.createElement('canvas');
                scaledCanvas.width = Math.round(tempCanvas.width * scaleFactor);
                scaledCanvas.height = Math.round(tempCanvas.height * scaleFactor);
                const scaledCtx = scaledCanvas.getContext('2d');
                
                // ä¼˜åŒ–2ï¼šä½¿ç”¨é«˜è´¨é‡çš„å›¾åƒç¼©æ”¾
                scaledCtx.imageSmoothingEnabled = true;
                scaledCtx.imageSmoothingQuality = 'high';
                scaledCtx.drawImage(tempCanvas, 0, 0, scaledCanvas.width, scaledCanvas.height);
                
                // æ£€æµ‹æ˜¯å¦å¯èƒ½æ˜¯ç»†ç¬”ç”»å­—æ¯ï¼ˆI, T, Lç­‰ï¼‰
                const isThinStroke = detectThinStroke(processedData);
                
                // ä¼˜åŒ–3ï¼šæ ¹æ®ç¬”ç”»ç²—ç»†é€‰æ‹©ä¸åŒçš„OCRé…ç½®
                const ocrConfig = {
                    logger: m => {}, // ç¦ç”¨æ—¥å¿—
                    
                    // æ ¸å¿ƒé…ç½®ï¼šåªä¿ç•™æœ€é‡è¦çš„å‚æ•°
                    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', // åªè¯†åˆ«å¤§å†™å­—æ¯
                    
                    // ä¼˜åŒ–4ï¼šæ ¹æ®ç¬”ç”»ç²—ç»†é€‰æ‹©PSMæ¨¡å¼
                    tessedit_pageseg_mode: isThinStroke ? '6' : '10', // ç»†ç¬”ç”»ç”¨PSM_SINGLE_BLOCKï¼Œå¦åˆ™PSM_SINGLE_CHAR
                    
                    // ä¼˜åŒ–5ï¼šä½¿ç”¨é»˜è®¤OCRå¼•æ“ï¼ˆè‡ªåŠ¨é€‰æ‹©æœ€ä½³ï¼‰
                    tessedit_ocr_engine_mode: '3', // DEFAULT - è‡ªåŠ¨é€‰æ‹©æœ€ä½³å¼•æ“
                    
                    // ä¼˜åŒ–6ï¼šç®€åŒ–å‚æ•°ï¼Œé¿å…å†²çª
                    classify_bln_numeric_mode: '0', // ç¦ç”¨æ•°å­—æ¨¡å¼
                    tessedit_single_match: '0', // å…è®¸å¤šä¸ªå€™é€‰
                };
                
                // å¯¹ç»†ç¬”ç”»å­—æ¯æ·»åŠ ç‰¹æ®Šå‚æ•°
                if (isThinStroke) {
                    ocrConfig.textord_min_linesize = '1.0'; // é™ä½æœ€å°è¡Œé«˜è¦æ±‚
                    ocrConfig.textord_excess_blobsize = '1.3'; // å…è®¸æ›´å°çš„blob
                }
                
                const result = await Tesseract.recognize(
                    scaledCanvas,
                    'eng',
                    ocrConfig
                );
                
                // ä»æ‰€æœ‰å€™é€‰ä¸­é€‰æ‹©ç½®ä¿¡åº¦æœ€é«˜çš„å­—æ¯
                let letter = '';
                let confidence = 0;
                
                // æ–¹æ³•1ï¼šä»symbolsä¸­æ‰¾åˆ°ç½®ä¿¡åº¦æœ€é«˜çš„å­—æ¯
                if (result.data.symbols && result.data.symbols.length > 0) {
                    let bestSymbol = null;
                    let bestConfidence = 0;
                    
                    result.data.symbols.forEach(symbol => {
                        let cleanText = symbol.text.trim().toUpperCase();
                        
                        // å¯¹ç»†ç¬”ç”»çš„ç‰¹æ®Šå¤„ç†ï¼šä¿®æ­£å¸¸è§è¯¯è¯†åˆ«
                        if (isThinStroke) {
                            // I å¸¸è¢«è¯†åˆ«ä¸º 1, l, |
                            if (cleanText === '1' || cleanText === 'L' || cleanText === '|') {
                                // å¦‚æœæ˜¯ç»†ç¬”ç”»ä¸”è¯†åˆ«ä¸ºè¿™äº›å­—ç¬¦ï¼Œå¾ˆå¯èƒ½æ˜¯ I
                                cleanText = 'I';
                            }
                        }
                        
                        if (/^[A-Z]$/.test(cleanText) && symbol.confidence > bestConfidence) {
                            bestSymbol = cleanText;
                            bestConfidence = symbol.confidence;
                        }
                    });
                    
                    if (bestSymbol) {
                        letter = bestSymbol;
                        confidence = bestConfidence;
                    }
                }
                
                // æ–¹æ³•2ï¼šå¦‚æœæ²¡æœ‰symbolsï¼Œä½¿ç”¨åŸå§‹text
                if (!letter && result.data.text) {
                    const text = result.data.text.trim().toUpperCase();
                    const cleanText = text.replace(/[^A-Z]/g, '');
                    if (cleanText.length > 0) {
                        letter = cleanText.charAt(0);
                        confidence = result.data.confidence || 0;
                    }
                }
                
                // æ”¶é›†æ‰€æœ‰å­—ç¬¦çš„ç½®ä¿¡åº¦ï¼ˆç”¨äºè°ƒè¯•ï¼‰
                if (returnDebugInfo && result.data.symbols) {
                    result.data.symbols.forEach(symbol => {
                        if (/[A-Z]/.test(symbol.text)) {
                            debugInfo.confidences[symbol.text] = symbol.confidence;
                        }
                    });
                    
                    // æ·»åŠ OCRä¼˜åŒ–ä¿¡æ¯
                    debugInfo.ocrOptimizations = {
                        scaleFactor: scaleFactor.toFixed(2),
                        psmMode: isThinStroke ? '6 (PSM_SINGLE_BLOCK)' : '10 (PSM_SINGLE_CHAR)',
                        ocrEngine: '3 (DEFAULT)',
                        originalSize: `${imageData.width}x${imageData.height}`,
                        scaledSize: `${scaledCanvas.width}x${scaledCanvas.height}`,
                        thinStroke: isThinStroke,
                        tips: [
                            scaleFactor === 1 ? 'å›¾åƒæœªç¼©æ”¾ï¼ˆå°ºå¯¸é€‚ä¸­ï¼‰' : 
                            scaleFactor < 2 ? 'é€‚åº¦ç¼©æ”¾ï¼Œè´¨é‡æœ€ä½³' : 
                            'å›¾åƒæ”¾å¤§ä»¥æé«˜è¯†åˆ«ç‡',
                            confidence > 85 ? 'âœ… è¯†åˆ«ç½®ä¿¡åº¦å¾ˆé«˜' : 
                            confidence > 70 ? 'âš ï¸ è¯†åˆ«ç½®ä¿¡åº¦ä¸­ç­‰' : 
                            'âŒ è¯†åˆ«ç½®ä¿¡åº¦ä½ï¼Œå¯èƒ½éœ€è¦è°ƒæ•´',
                            isThinStroke ? 'ğŸ” æ£€æµ‹åˆ°ç»†ç¬”ç”»å­—æ¯ï¼ˆI/T/Lï¼‰ï¼Œä½¿ç”¨ç‰¹æ®Šå‚æ•°' : 'æ ‡å‡†ç¬”ç”»ï¼Œä½¿ç”¨å¸¸è§„å‚æ•°'
                        ]
                    };
                }
                
                // ç®€åŒ–ï¼šä¸å†å°è¯•å¢å¼ºå¯¹æ¯”åº¦ï¼Œç›´æ¥è¿”å›æœ€é«˜ç½®ä¿¡åº¦çš„ç»“æœ
                // å¦‚æœæ²¡æœ‰è¯†åˆ«åˆ°ä»»ä½•å­—æ¯ï¼Œå°è¯•ä½¿ç”¨ä¸åŒçš„PSMæ¨¡å¼
                if (!letter && imageData) {
                    console.log('ç¬¬ä¸€æ¬¡è¯†åˆ«æœªæ‰¾åˆ°å­—æ¯ï¼Œå°è¯•PSM_RAW_LINEæ¨¡å¼');
                    
                    // å°è¯•ä¸åŒçš„PSMæ¨¡å¼ï¼ˆæœ‰æ—¶å¯¹ç‰¹æ®Šæƒ…å†µæ•ˆæœæ›´å¥½ï¼‰
                    const result2 = await Tesseract.recognize(
                        scaledCanvas,  // ä½¿ç”¨åŒæ ·çš„ç¼©æ”¾å›¾åƒ
                        'eng',
                        {
                            logger: m => {},
                            tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
                            tessedit_pageseg_mode: '13', // PSM_RAW_LINE - åŸå§‹æ–‡æœ¬è¡Œ
                            tessedit_ocr_engine_mode: '3', // DEFAULT
                        }
                    );
                    
                    // ä»ç¬¬äºŒæ¬¡è¯†åˆ«ä¸­é€‰æ‹©ç½®ä¿¡åº¦æœ€é«˜çš„å­—æ¯
                    if (result2.data.symbols && result2.data.symbols.length > 0) {
                        result2.data.symbols.forEach(symbol => {
                            const cleanText = symbol.text.trim().toUpperCase();
                            if (/^[A-Z]$/.test(cleanText) && symbol.confidence > confidence) {
                                letter = cleanText;
                                confidence = symbol.confidence;
                                
                                if (returnDebugInfo) {
                                    debugInfo.confidences[cleanText] = symbol.confidence;
                                }
                            }
                        });
                    }
                }
                
                if (returnDebugInfo) {
                    return {
                        letter: letter,
                        confidence: Math.round(confidence),
                        debugInfo: debugInfo
                    };
                }
                
                return {
                    letter: letter,
                    confidence: Math.round(confidence)
                };
            } catch (error) {
                console.error('OCRé”™è¯¯:', error);
                // å¦‚æœOCRå¤±è´¥ï¼Œå›é€€åˆ°ç®€å•çš„æ¨¡æ¿åŒ¹é…
                return fallbackLetterRecognition(imageData);
            }
        }
        
        // æ£€æµ‹æ˜¯å¦æ˜¯ç»†ç¬”ç”»ï¼ˆå¦‚å­—æ¯Iã€Tã€Lï¼‰
        function detectThinStroke(imageData) {
            const { width, height, data } = imageData;
            let blackPixels = 0;
            let totalPixels = width * height;
            
            // ç»Ÿè®¡é»‘è‰²åƒç´ ï¼ˆæ–‡å­—ï¼‰
            for (let i = 0; i < data.length; i += 4) {
                const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                if (brightness < 128) { // é»‘è‰²æˆ–æ·±è‰²
                    blackPixels++;
                }
            }
            
            const blackRatio = blackPixels / totalPixels;
            
            // å¦‚æœé»‘è‰²åƒç´ å°‘äº8%ï¼Œè®¤ä¸ºæ˜¯ç»†ç¬”ç”»
            // Ié€šå¸¸åªæœ‰3-5%ï¼ŒTçº¦5-7%ï¼ŒLçº¦6-8%
            return blackRatio < 0.08;
        }
        
        // é¢„å¤„ç†å›¾åƒä»¥æé«˜OCRå‡†ç¡®åº¦
        function preprocessForOCR(imageData) {
            const { width, height, data } = imageData;
            const output = new ImageData(width, height);
            const outputData = output.data;
            
            // è·å–å½“å‰é…è‰²æ–¹æ¡ˆ
            const schemeSelect = document.getElementById('colorSchemeSelect');
            const scheme = schemeSelect ? schemeSelect.value : 'auto';
            
            // ç®€å•è€Œå¯é çš„æ–¹æ³•ï¼šä½¿ç”¨Otsu'sæ–¹æ³•æ‰¾é˜ˆå€¼
            // 1. è®¡ç®—ç›´æ–¹å›¾
            const histogram = new Array(256).fill(0);
            let totalPixels = 0;
            for (let i = 0; i < data.length; i += 4) {
                const brightness = Math.round((data[i] + data[i + 1] + data[i + 2]) / 3);
                histogram[brightness]++;
                totalPixels++;
            }
            
            // 2. Otsu'sæ–¹æ³•æ‰¾æœ€ä½³é˜ˆå€¼
            let sum = 0;
            for (let i = 0; i < 256; i++) {
                sum += i * histogram[i];
            }
            
            let sumB = 0;
            let wB = 0;
            let wF = 0;
            let maxVariance = 0;
            let threshold = 0;
            
            for (let t = 0; t < 256; t++) {
                wB += histogram[t];
                if (wB === 0) continue;
                
                wF = totalPixels - wB;
                if (wF === 0) break;
                
                sumB += t * histogram[t];
                
                const mB = sumB / wB;
                const mF = (sum - sumB) / wF;
                
                const variance = wB * wF * (mB - mF) * (mB - mF);
                
                if (variance > maxVariance) {
                    maxVariance = variance;
                    threshold = t;
                }
            }
            
            // 3. åˆ¤æ–­èƒŒæ™¯æ˜¯æ·±è‰²è¿˜æ˜¯æµ…è‰²
            let darkPixels = 0;
            let lightPixels = 0;
            for (let i = 0; i < data.length; i += 4) {
                const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                if (brightness < threshold) {
                    darkPixels++;
                } else {
                    lightPixels++;
                }
            }
            
            const isDarkBackground = darkPixels > lightPixels;
            
            // 4. æ ¹æ®é…è‰²æ–¹æ¡ˆå¾®è°ƒé˜ˆå€¼
            let adjustedThreshold = threshold;
            if (scheme === 'lessgames.com') {
                // lessgames.comé€šå¸¸æœ‰æ·±è‰²èƒŒæ™¯ï¼Œç¨å¾®è°ƒæ•´é˜ˆå€¼ä»¥ä¿ç•™æ›´å¤šç»†èŠ‚
                // é™ä½é˜ˆå€¼å¯ä»¥è®©æ›´å¤šåƒç´ è¢«è¯†åˆ«ä¸ºæ–‡å­—ï¼ˆé¿å…ç»†ç¬”ç”»ä¸¢å¤±ï¼‰
                adjustedThreshold = isDarkBackground ? threshold - 15 : threshold + 15;
            } else if (scheme === 'wordle2.io') {
                // wordle2.ioå¯èƒ½æœ‰å„ç§é¢œè‰²ï¼Œç¨å¾®è°ƒæ•´ä»¥ä¿ç•™ç»†èŠ‚
                adjustedThreshold = isDarkBackground ? threshold - 5 : threshold + 5;
            } else {
                // è‡ªåŠ¨æ¨¡å¼ï¼šè½»å¾®è°ƒæ•´
                adjustedThreshold = isDarkBackground ? threshold - 8 : threshold + 8;
            }
            
            // ç¡®ä¿é˜ˆå€¼åœ¨æœ‰æ•ˆèŒƒå›´å†…
            adjustedThreshold = Math.max(0, Math.min(255, adjustedThreshold));
            
            // è°ƒè¯•ä¿¡æ¯ï¼ˆå¯ä»¥åœ¨æ§åˆ¶å°çœ‹åˆ°ï¼‰
            console.log(`é¢„å¤„ç†è°ƒè¯•ä¿¡æ¯:
                Otsué˜ˆå€¼: ${threshold}
                è°ƒæ•´åé˜ˆå€¼: ${adjustedThreshold}
                èƒŒæ™¯ç±»å‹: ${isDarkBackground ? 'æ·±è‰²' : 'æµ…è‰²'}
                æ·±è‰²åƒç´ : ${darkPixels} (${(darkPixels/totalPixels*100).toFixed(1)}%)
                æµ…è‰²åƒç´ : ${lightPixels} (${(lightPixels/totalPixels*100).toFixed(1)}%)
                é…è‰²æ–¹æ¡ˆ: ${scheme}
                ç›®æ ‡: è¾“å‡ºç™½åº•é»‘å­—ï¼ˆOCRæ ‡å‡†æ ¼å¼ï¼‰
            `);
            
            // 5. ç¬¬ä¸€æ­¥äºŒå€¼åŒ–
            const binaryData = new Uint8ClampedArray(width * height);
            for (let i = 0, j = 0; i < data.length; i += 4, j++) {
                const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                binaryData[j] = brightness > adjustedThreshold ? 1 : 0;
            }
            
            // 6. æ”¹è¿›çš„æ£€æµ‹æ–¹æ³•ï¼šåˆ†æåŸå§‹å›¾åƒçš„è¾¹ç¼˜å’Œä¸­å¿ƒäº®åº¦
            // ä¸æ˜¯åŸºäºäºŒå€¼åŒ–åçš„æ•°æ®ï¼Œè€Œæ˜¯åŸºäºåŸå§‹äº®åº¦
            const edgeSize = Math.floor(Math.min(width, height) * 0.15);
            let edgeBrightSum = 0, edgeCount = 0;
            let centerBrightSum = 0, centerCount = 0;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                    
                    const isEdge = x < edgeSize || x >= width - edgeSize || 
                                  y < edgeSize || y >= height - edgeSize;
                    
                    if (isEdge) {
                        edgeBrightSum += brightness;
                        edgeCount++;
                    } else {
                        centerBrightSum += brightness;
                        centerCount++;
                    }
                }
            }
            
            const edgeAvgBright = edgeBrightSum / edgeCount;
            const centerAvgBright = centerBrightSum / centerCount;
            
            // åˆ¤æ–­æ˜¯å¦éœ€è¦åè½¬
            // å¦‚æœä¸­å¿ƒæ¯”è¾¹ç¼˜äº®ï¼Œè¯´æ˜æ–‡å­—æ˜¯ç™½è‰²çš„ï¼ŒèƒŒæ™¯æ˜¯æ·±è‰²çš„ï¼Œéœ€è¦åè½¬æˆé»‘å­—ç™½èƒŒæ™¯
            let needInvert = false;
            
            if (centerAvgBright > edgeAvgBright + 10) {
                // ç™½å­—æ·±èƒŒæ™¯ï¼šéœ€è¦åè½¬æˆé»‘å­—ç™½èƒŒæ™¯
                needInvert = true;
                console.log('æ£€æµ‹åˆ°ï¼šç™½å­—æ·±èƒŒæ™¯ï¼Œéœ€è¦åè½¬');
            } else if (edgeAvgBright > centerAvgBright + 10) {
                // é»‘å­—æµ…èƒŒæ™¯ï¼šå·²ç»æ˜¯æ­£ç¡®æ ¼å¼
                needInvert = false;
                console.log('æ£€æµ‹åˆ°ï¼šé»‘å­—æµ…èƒŒæ™¯ï¼Œä¸éœ€è¦åè½¬');
            } else {
                // å¯¹æ¯”åº¦ä¸æ˜æ˜¾ï¼Œä½¿ç”¨äºŒå€¼åŒ–åçš„ç»Ÿè®¡
                let edgeWhite = 0, edgeBlack = 0;
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = y * width + x;
                        const isEdge = x < edgeSize || x >= width - edgeSize || 
                                      y < edgeSize || y >= height - edgeSize;
                        if (isEdge) {
                            if (binaryData[idx] === 1) edgeWhite++;
                            else edgeBlack++;
                        }
                    }
                }
                needInvert = edgeWhite < edgeBlack;
            }
            
            // æ£€æŸ¥æ˜¯å¦æ•´ä¸ªå›¾åƒå‡ ä¹å…¨ç™½æˆ–å…¨é»‘ï¼ˆå¯èƒ½æ˜¯é˜ˆå€¼å¤±æ•ˆï¼‰
            let totalWhite = 0, totalBlack = 0;
            for (let i = 0; i < binaryData.length; i++) {
                if (binaryData[i] === 1) totalWhite++;
                else totalBlack++;
            }
            
            // ç‰¹æ®Šæƒ…å†µå¤„ç†ï¼šå¦‚æœå›¾åƒå‡ ä¹å…¨ç™½æˆ–å…¨é»‘ï¼ˆOtsuå¤±æ•ˆï¼‰
            if (totalWhite > totalPixels * 0.95 || totalBlack > totalPixels * 0.95) {
                console.log('è­¦å‘Šï¼šOtsué˜ˆå€¼å¯èƒ½å¤±æ•ˆï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ³•');
                
                // å¤‡ç”¨æ–¹æ³•ï¼šé‡æ–°è®¡ç®—é˜ˆå€¼
                // æ‰¾æœ€äº®å’Œæœ€æš—çš„10%åƒç´ çš„å¹³å‡å€¼
                const sortedBrightness = [];
                for (let i = 0; i < data.length; i += 4) {
                    sortedBrightness.push((data[i] + data[i + 1] + data[i + 2]) / 3);
                }
                sortedBrightness.sort((a, b) => a - b);
                
                const tenPercent = Math.floor(sortedBrightness.length * 0.1);
                let darkAvg = 0, lightAvg = 0;
                
                for (let i = 0; i < tenPercent; i++) {
                    darkAvg += sortedBrightness[i];
                    lightAvg += sortedBrightness[sortedBrightness.length - 1 - i];
                }
                darkAvg /= tenPercent;
                lightAvg /= tenPercent;
                
                // ä½¿ç”¨æ–°é˜ˆå€¼é‡æ–°äºŒå€¼åŒ–
                const newThreshold = (darkAvg + lightAvg) / 2;
                console.log(`ä½¿ç”¨å¤‡ç”¨é˜ˆå€¼: ${newThreshold} (åŸOtsu: ${threshold})`);
                
                // é‡æ–°äºŒå€¼åŒ–
                for (let i = 0, j = 0; i < data.length; i += 4, j++) {
                    const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    binaryData[j] = brightness > newThreshold ? 1 : 0;
                }
                
                // é‡æ–°ç»Ÿè®¡ä»¥å†³å®šæ˜¯å¦åè½¬
                let newWhiteCount = 0;
                for (let i = 0; i < binaryData.length; i++) {
                    if (binaryData[i] === 1) newWhiteCount++;
                }
                
                // ä¸€èˆ¬æƒ…å†µä¸‹ï¼ŒèƒŒæ™¯åƒç´ æ›´å¤šï¼Œæ–‡å­—åƒç´ æ›´å°‘
                // å¦‚æœç™½è‰²åƒç´ æ›´å¤šï¼Œè¯´æ˜ç™½è‰²æ˜¯èƒŒæ™¯ï¼Œä¸éœ€è¦åè½¬ï¼ˆå·²ç»æ˜¯OCRæ ‡å‡†æ ¼å¼ï¼‰
                // å¦‚æœé»‘è‰²åƒç´ æ›´å¤šï¼Œè¯´æ˜é»‘è‰²æ˜¯èƒŒæ™¯ï¼Œéœ€è¦åè½¬ä¸ºç™½åº•é»‘å­—
                needInvert = newWhiteCount <= binaryData.length * 0.5;
            }
            
            console.log(`é¢œè‰²åˆ†å¸ƒ:
                è¾¹ç¼˜å¹³å‡äº®åº¦: ${edgeAvgBright.toFixed(1)}
                ä¸­å¿ƒå¹³å‡äº®åº¦: ${centerAvgBright.toFixed(1)}
                äº®åº¦å·®: ${(centerAvgBright - edgeAvgBright).toFixed(1)}
                éœ€è¦åè½¬: ${needInvert} (ç›®æ ‡ï¼šç™½åº•é»‘å­—)
            `);
            
            // 7. å¯é€‰ï¼šå¯¹ç»†ç¬”ç”»è¿›è¡Œè½»å¾®è†¨èƒ€ï¼ˆç‰¹åˆ«æ˜¯Tã€Iã€Lç­‰ï¼‰
            // è®¡ç®—é»‘è‰²åƒç´ çš„æ¯”ä¾‹
            let blackPixelRatio = 0;
            for (let i = 0; i < binaryData.length; i++) {
                if ((needInvert && binaryData[i] === 1) || (!needInvert && binaryData[i] === 0)) {
                    blackPixelRatio++;
                }
            }
            blackPixelRatio /= binaryData.length;
            
            // å¦‚æœé»‘è‰²åƒç´ å¤ªå°‘ï¼ˆ<5%ï¼‰ï¼Œå¯èƒ½æ˜¯ç»†ç¬”ç”»ï¼Œè¿›è¡Œè½»å¾®è†¨èƒ€
            const dilatedData = new Uint8ClampedArray(binaryData);
            if (blackPixelRatio < 0.05 && blackPixelRatio > 0.01) {
                console.log('æ£€æµ‹åˆ°ç»†ç¬”ç”»ï¼Œè¿›è¡Œè½»å¾®è†¨èƒ€å¤„ç†');
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = y * width + x;
                        // å¦‚æœå‘¨å›´æœ‰é»‘è‰²åƒç´ ï¼Œå½“å‰åƒç´ ä¹Ÿå˜é»‘ï¼ˆ3x3è†¨èƒ€ï¼‰
                        const targetValue = needInvert ? 1 : 0;
                        if (binaryData[idx - width] === targetValue ||
                            binaryData[idx + width] === targetValue ||
                            binaryData[idx - 1] === targetValue ||
                            binaryData[idx + 1] === targetValue) {
                            dilatedData[idx] = targetValue;
                        }
                    }
                }
            }
            
            // 8. ç”Ÿæˆæœ€ç»ˆçš„ç™½åº•é»‘å­—å›¾åƒï¼ˆOCRæ ‡å‡†æ ¼å¼ï¼‰
            for (let i = 0, j = 0; i < outputData.length; i += 4, j++) {
                let pixelValue;
                const useData = blackPixelRatio < 0.05 && blackPixelRatio > 0.01 ? dilatedData : binaryData;
                
                if (needInvert) {
                    // éœ€è¦åè½¬ï¼ˆæ·±è‰²èƒŒæ™¯ â†’ ç™½åº•é»‘å­—ï¼‰ï¼š1ï¼ˆç™½ï¼‰å˜0ï¼ˆé»‘ï¼‰ï¼Œ0ï¼ˆé»‘ï¼‰å˜255ï¼ˆç™½ï¼‰
                    pixelValue = useData[j] === 1 ? 0 : 255;
                } else {
                    // ä¸éœ€è¦åè½¬ï¼ˆå·²ç»æ˜¯ç™½åº•é»‘å­—ï¼‰ï¼š1ï¼ˆç™½ï¼‰ä¿æŒ255ï¼ˆç™½ï¼‰ï¼Œ0ï¼ˆé»‘ï¼‰ä¿æŒ0ï¼ˆé»‘ï¼‰
                    pixelValue = useData[j] === 1 ? 255 : 0;
                }
                
                outputData[i] = pixelValue;
                outputData[i + 1] = pixelValue;
                outputData[i + 2] = pixelValue;
                outputData[i + 3] = 255;
            }
            
            return output;
        }
        
        // å¢å¼ºå¯¹æ¯”åº¦çš„é¢„å¤„ç†ï¼ˆæ›´æ¿€è¿›çš„æ–¹æ³•ï¼‰
        function enhanceContrastForOCR(imageData) {
            const { width, height, data } = imageData;
            
            // ç¬¬ä¸€æ­¥ï¼šä½¿ç”¨æ”¹è¿›çš„è‡ªé€‚åº”é˜ˆå€¼å¤„ç†
            const enhanced1 = applyAdaptiveThreshold(imageData);
            
            // ç¬¬äºŒæ­¥ï¼šå½¢æ€å­¦é—­è¿ç®—ï¼ˆè¿æ¥æ–­å¼€çš„ç¬”ç”»ï¼‰
            const enhanced2 = applyMorphologicalClosing(enhanced1, width, height);
            
            // ç¬¬ä¸‰æ­¥ï¼šå»é™¤å°å™ªç‚¹
            const enhanced3 = removeSmallNoise(enhanced2, width, height);
            
            return enhanced3;
        }
        
        // è‡ªé€‚åº”é˜ˆå€¼å¤„ç†
        function applyAdaptiveThreshold(imageData) {
            const { width, height, data } = imageData;
            const output = new ImageData(width, height);
            const outputData = output.data;
            
            // è®¡ç®—å±€éƒ¨å¹³å‡å€¼å’Œæ ‡å‡†å·®
            const windowSize = Math.max(3, Math.min(width, height) / 8);
            const halfWindow = Math.floor(windowSize / 2);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const centerIdx = (y * width + x) * 4;
                    
                    // è®¡ç®—çª—å£å†…çš„ç»Ÿè®¡ä¿¡æ¯
                    let sum = 0, count = 0, sumSquared = 0;
                    
                    for (let dy = -halfWindow; dy <= halfWindow; dy++) {
                        for (let dx = -halfWindow; dx <= halfWindow; dx++) {
                            const ny = y + dy;
                            const nx = x + dx;
                            if (ny >= 0 && ny < height && nx >= 0 && nx < width) {
                                const idx = (ny * width + nx) * 4;
                                const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                                sum += brightness;
                                sumSquared += brightness * brightness;
                                count++;
                            }
                        }
                    }
                    
                    const mean = sum / count;
                    const variance = (sumSquared / count) - (mean * mean);
                    const stdDev = Math.sqrt(variance);
                    
                    // å½“å‰åƒç´ çš„äº®åº¦
                    const currentBrightness = (data[centerIdx] + data[centerIdx + 1] + data[centerIdx + 2]) / 3;
                    
                    // è‡ªé€‚åº”é˜ˆå€¼ï¼šå‡å€¼ - k * æ ‡å‡†å·®
                    const k = 0.2;
                    const threshold = mean - k * stdDev;
                    
                    // äºŒå€¼åŒ–å†³ç­–
                    const isText = currentBrightness < threshold;
                    const value = isText ? 0 : 255; // é»‘å­—ç™½åº•
                    
                    outputData[centerIdx] = outputData[centerIdx + 1] = outputData[centerIdx + 2] = value;
                    outputData[centerIdx + 3] = 255;
                }
            }
            
            return output;
        }
        
        // å½¢æ€å­¦é—­è¿ç®—ï¼ˆå…ˆè†¨èƒ€åè…èš€ï¼Œè¿æ¥æ–­å¼€çš„ç¬”ç”»ï¼‰
        function applyMorphologicalClosing(imageData, width, height) {
            // è†¨èƒ€æ“ä½œ
            const dilated = applyDilation(imageData, width, height);
            // è…èš€æ“ä½œ
            const closed = applyErosion(dilated, width, height);
            return closed;
        }
        
        // è†¨èƒ€æ“ä½œ
        function applyDilation(imageData, width, height) {
            const output = new ImageData(width, height);
            const data = imageData.data;
            const outputData = output.data;
            
            // 3x3ç»“æ„å…ƒç´ 
            const kernel = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 0], [0, 1], [1, -1], [1, 0], [1, 1]];
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let hasBlackNeighbor = false;
                    
                    for (const [dy, dx] of kernel) {
                        const ny = y + dy;
                        const nx = x + dx;
                        const idx = (ny * width + nx) * 4;
                        if (data[idx] === 0) { // å¦‚æœé‚»åŸŸæœ‰é»‘åƒç´ 
                            hasBlackNeighbor = true;
                            break;
                        }
                    }
                    
                    const currentIdx = (y * width + x) * 4;
                    const value = hasBlackNeighbor ? 0 : 255;
                    outputData[currentIdx] = outputData[currentIdx + 1] = outputData[currentIdx + 2] = value;
                    outputData[currentIdx + 3] = 255;
                }
            }
            
            // å¤åˆ¶è¾¹ç•Œ
            for (let i = 0; i < data.length; i += 4) {
                if (outputData[i + 3] === 0) { // æœªå¤„ç†çš„åƒç´ 
                    outputData[i] = data[i];
                    outputData[i + 1] = data[i + 1];
                    outputData[i + 2] = data[i + 2];
                    outputData[i + 3] = 255;
                }
            }
            
            return output;
        }
        
        // è…èš€æ“ä½œ
        function applyErosion(imageData, width, height) {
            const output = new ImageData(width, height);
            const data = imageData.data;
            const outputData = output.data;
            
            // 3x3ç»“æ„å…ƒç´ 
            const kernel = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 0], [0, 1], [1, -1], [1, 0], [1, 1]];
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let allNeighborsBlack = true;
                    
                    for (const [dy, dx] of kernel) {
                        const ny = y + dy;
                        const nx = x + dx;
                        const idx = (ny * width + nx) * 4;
                        if (data[idx] !== 0) { // å¦‚æœé‚»åŸŸæœ‰ç™½åƒç´ 
                            allNeighborsBlack = false;
                            break;
                        }
                    }
                    
                    const currentIdx = (y * width + x) * 4;
                    const value = allNeighborsBlack ? 0 : 255;
                    outputData[currentIdx] = outputData[currentIdx + 1] = outputData[currentIdx + 2] = value;
                    outputData[currentIdx + 3] = 255;
                }
            }
            
            // å¤åˆ¶è¾¹ç•Œ
            for (let i = 0; i < data.length; i += 4) {
                if (outputData[i + 3] === 0) { // æœªå¤„ç†çš„åƒç´ 
                    outputData[i] = data[i];
                    outputData[i + 1] = data[i + 1];
                    outputData[i + 2] = data[i + 2];
                    outputData[i + 3] = 255;
                }
            }
            
            return output;
        }
        
        // å»é™¤å°å™ªç‚¹
        function removeSmallNoise(imageData, width, height) {
            const output = new ImageData(width, height);
            const data = imageData.data;
            const outputData = output.data;
            
            // å¤åˆ¶åŸå§‹æ•°æ®
            for (let i = 0; i < data.length; i++) {
                outputData[i] = data[i];
            }
            
            // è¿é€šç»„ä»¶åˆ†æï¼Œå»é™¤å°çš„é»‘è‰²åŒºåŸŸ
            const visited = new Array(width * height).fill(false);
            const minComponentSize = Math.max(3, (width * height) / 100); // è‡³å°‘è¦æœ‰1%çš„åƒç´ 
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    if (!visited[idx] && data[idx * 4] === 0) { // é»‘è‰²åƒç´ ä¸”æœªè®¿é—®
                        const component = floodFill(data, visited, x, y, width, height);
                        if (component.length < minComponentSize) {
                            // å°†å°ç»„ä»¶å˜ä¸ºç™½è‰²
                            for (const pixelIdx of component) {
                                outputData[pixelIdx * 4] = 255;
                                outputData[pixelIdx * 4 + 1] = 255;
                                outputData[pixelIdx * 4 + 2] = 255;
                            }
                        }
                    }
                }
            }
            
            return output;
        }
        
        // æ³›æ´ªå¡«å……ç®—æ³•
        function floodFill(data, visited, startX, startY, width, height) {
            const stack = [{x: startX, y: startY}];
            const component = [];
            
            while (stack.length > 0) {
                const {x, y} = stack.pop();
                const idx = y * width + x;
                
                if (x < 0 || x >= width || y < 0 || y >= height || visited[idx] || data[idx * 4] !== 0) {
                    continue;
                }
                
                visited[idx] = true;
                component.push(idx);
                
                // æ·»åŠ 4è¿é€šé‚»åŸŸ
                stack.push({x: x + 1, y: y});
                stack.push({x: x - 1, y: y});
                stack.push({x: x, y: y + 1});
                stack.push({x: x, y: y - 1});
            }
            
            return component;
        }
        
        // ç®€å•çš„åå¤‡å­—æ¯è¯†åˆ«
        function fallbackLetterRecognition(imageData) {
            // ä¿ç•™åŸæ¥çš„ç®€å•æ¨¡æ¿åŒ¹é…ä½œä¸ºåå¤‡
            const letterImage = extractLetterRegion(imageData);
            const features = extractLetterFeatures(letterImage);
            const result = matchLetterTemplate(features);
            return result;
        }
        
        // æå–å­—æ¯åŒºåŸŸï¼ˆå»é™¤èƒŒæ™¯ï¼‰
        function extractLetterRegion(imageData) {
            const { width, height, data } = imageData;
            const binaryImage = new Uint8ClampedArray(width * height);
            
            // å…ˆæ‰¾åˆ°èƒŒæ™¯è‰²ï¼ˆè¾¹ç¼˜çš„ä¸»è¦é¢œè‰²ï¼‰
            let bgBrightness = 0;
            let bgCount = 0;
            const edgeWidth = Math.floor(width * 0.1);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    // åªé‡‡æ ·è¾¹ç¼˜
                    if (x < edgeWidth || x >= width - edgeWidth || 
                        y < edgeWidth || y >= height - edgeWidth) {
                        const idx = (y * width + x) * 4;
                        bgBrightness += (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                        bgCount++;
                    }
                }
            }
            
            const avgBg = bgCount > 0 ? bgBrightness / bgCount : 128;
            
            // åŠ¨æ€é˜ˆå€¼ï¼šèƒŒæ™¯äº®åº¦çš„ä¸­ç‚¹
            const threshold = avgBg > 128 ? avgBg - 40 : avgBg + 40;
            
            // è½¬æ¢ä¸ºäºŒå€¼å›¾åƒï¼Œæ ¹æ®èƒŒæ™¯æ˜¯æ·±è‰²è¿˜æ˜¯æµ…è‰²å†³å®šåè½¬
            const invertColors = avgBg < 128;
            
            for (let i = 0; i < data.length; i += 4) {
                const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                if (invertColors) {
                    // æ·±è‰²èƒŒæ™¯ï¼Œæµ…è‰²æ–‡å­—
                    binaryImage[i / 4] = brightness > threshold ? 1 : 0;
                } else {
                    // æµ…è‰²èƒŒæ™¯ï¼Œæ·±è‰²æ–‡å­—
                    binaryImage[i / 4] = brightness < threshold ? 1 : 0;
                }
            }
            
            // æ‰¾åˆ°å­—æ¯çš„è¾¹ç•Œ
            let minX = width, maxX = 0;
            let minY = height, maxY = 0;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (binaryImage[y * width + x] === 1) {
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                    }
                }
            }
            
            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å­—æ¯åŒºåŸŸ
            if (minX > maxX || minY > maxY) {
                return { data: binaryImage, width, height, bounds: null };
            }
            
            return {
                data: binaryImage,
                width,
                height,
                bounds: { minX, maxX, minY, maxY }
            };
        }
        
        // æå–å­—æ¯ç‰¹å¾
        function extractLetterFeatures(letterImage) {
            const { data, width, height, bounds } = letterImage;
            
            if (!bounds) {
                return { 
                    verticalProfile: [], 
                    horizontalProfile: [],
                    density: 0,
                    aspectRatio: 1
                };
            }
            
            const { minX, maxX, minY, maxY } = bounds;
            const letterWidth = maxX - minX + 1;
            const letterHeight = maxY - minY + 1;
            
            // å‚ç›´æŠ•å½±ï¼ˆæ¯åˆ—çš„é»‘ç‚¹æ•°ï¼‰
            const verticalProfile = [];
            for (let x = minX; x <= maxX; x++) {
                let count = 0;
                for (let y = minY; y <= maxY; y++) {
                    if (data[y * width + x] === 1) count++;
                }
                verticalProfile.push(count / letterHeight);
            }
            
            // æ°´å¹³æŠ•å½±ï¼ˆæ¯è¡Œçš„é»‘ç‚¹æ•°ï¼‰
            const horizontalProfile = [];
            for (let y = minY; y <= maxY; y++) {
                let count = 0;
                for (let x = minX; x <= maxX; x++) {
                    if (data[y * width + x] === 1) count++;
                }
                horizontalProfile.push(count / letterWidth);
            }
            
            // å¯†åº¦ç‰¹å¾
            let blackPixels = 0;
            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    if (data[y * width + x] === 1) blackPixels++;
                }
            }
            const density = blackPixels / (letterWidth * letterHeight);
            
            // å®½é«˜æ¯”
            const aspectRatio = letterWidth / letterHeight;
            
            return {
                verticalProfile,
                horizontalProfile,
                density,
                aspectRatio,
                width: letterWidth,
                height: letterHeight
            };
        }
        
        // æ¨¡æ¿åŒ¹é…è¯†åˆ«å­—æ¯
        function matchLetterTemplate(features) {
            // ç®€åŒ–çš„å­—æ¯ç‰¹å¾æ¨¡æ¿
            const templates = {
                'A': { density: 0.35, aspectRatio: 0.7, hasHole: true },
                'B': { density: 0.45, aspectRatio: 0.6, hasHole: true },
                'C': { density: 0.30, aspectRatio: 0.7, hasHole: false },
                'D': { density: 0.40, aspectRatio: 0.7, hasHole: true },
                'E': { density: 0.35, aspectRatio: 0.6, hasHole: false },
                'F': { density: 0.30, aspectRatio: 0.6, hasHole: false },
                'G': { density: 0.35, aspectRatio: 0.7, hasHole: false },
                'H': { density: 0.35, aspectRatio: 0.7, hasHole: false },
                'I': { density: 0.25, aspectRatio: 0.3, hasHole: false },
                'J': { density: 0.25, aspectRatio: 0.5, hasHole: false },
                'K': { density: 0.35, aspectRatio: 0.7, hasHole: false },
                'L': { density: 0.25, aspectRatio: 0.6, hasHole: false },
                'M': { density: 0.40, aspectRatio: 0.8, hasHole: false },
                'N': { density: 0.35, aspectRatio: 0.7, hasHole: false },
                'O': { density: 0.35, aspectRatio: 0.8, hasHole: true },
                'P': { density: 0.35, aspectRatio: 0.6, hasHole: true },
                'Q': { density: 0.40, aspectRatio: 0.8, hasHole: true },
                'R': { density: 0.40, aspectRatio: 0.7, hasHole: true },
                'S': { density: 0.35, aspectRatio: 0.6, hasHole: false },
                'T': { density: 0.25, aspectRatio: 0.7, hasHole: false },
                'U': { density: 0.30, aspectRatio: 0.7, hasHole: false },
                'V': { density: 0.30, aspectRatio: 0.8, hasHole: false },
                'W': { density: 0.40, aspectRatio: 0.9, hasHole: false },
                'X': { density: 0.30, aspectRatio: 0.7, hasHole: false },
                'Y': { density: 0.25, aspectRatio: 0.7, hasHole: false },
                'Z': { density: 0.30, aspectRatio: 0.7, hasHole: false }
            };
            
            let bestMatch = '';
            let bestScore = 0;
            
            // åŸºäºå¯†åº¦å’Œå®½é«˜æ¯”çš„ç®€å•åŒ¹é…
            for (const [letter, template] of Object.entries(templates)) {
                const densityDiff = Math.abs(features.density - template.density);
                const aspectDiff = Math.abs(features.aspectRatio - template.aspectRatio);
                
                // è®¡ç®—ç›¸ä¼¼åº¦å¾—åˆ†
                const score = Math.max(0, 1 - densityDiff * 2 - aspectDiff);
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMatch = letter;
                }
            }
            
            // å¦‚æœç‰¹å¾å¤ªå¼±ï¼Œè¿”å›ç©º
            if (features.density < 0.1 || bestScore < 0.3) {
                return { letter: '', confidence: 0 };
            }
            
            return {
                letter: bestMatch,
                confidence: Math.round(bestScore * 100)
            };
        }
        
        // æ˜¾ç¤ºOCRè°ƒè¯•é¢æ¿
        async function showDebugPanel(cellData, row, col) {
            const panel = document.getElementById('ocrDebugPanel');
            const debugContent = document.getElementById('debugContent');
            const confidenceChart = document.getElementById('confidenceChart');
            
            // æ˜¾ç¤ºåŠ è½½ä¸­
            debugContent.innerHTML = '<p>æ­£åœ¨åˆ†æå­—æ¯è¯†åˆ«è¿‡ç¨‹...</p>';
            confidenceChart.innerHTML = '';
            panel.classList.add('active');
            
            // æ‰§è¡Œå¸¦è°ƒè¯•ä¿¡æ¯çš„è¯†åˆ«
            const result = await recognizeLetter(cellData, true);
            
            // æ˜¾ç¤ºå„ä¸ªé˜¶æ®µçš„å›¾åƒ
            debugContent.innerHTML = '';
            if (result.debugInfo && result.debugInfo.stages) {
                result.debugInfo.stages.forEach(stage => {
                    const stageDiv = document.createElement('div');
                    stageDiv.className = 'debug-stage';
                    stageDiv.innerHTML = `
                        <h4>${stage.name}</h4>
                        <img src="${stage.dataUrl}" class="debug-canvas" />
                    `;
                    debugContent.appendChild(stageDiv);
                });
            }
            
            // æ˜¾ç¤ºç½®ä¿¡åº¦å›¾è¡¨
            confidenceChart.innerHTML = '<h4>å­—æ¯ç½®ä¿¡åº¦åˆ†å¸ƒ</h4>';
            
            // è·å–æ‰€æœ‰å­—æ¯çš„ç½®ä¿¡åº¦
            const confidences = result.debugInfo?.confidences || {};
            
            // å¦‚æœæœ‰è¯†åˆ«ç»“æœï¼Œç¡®ä¿å®ƒåœ¨åˆ—è¡¨ä¸­
            if (result.letter && !confidences[result.letter]) {
                confidences[result.letter] = result.confidence;
            }
            
            // æ’åºå¹¶æ˜¾ç¤ºå‰10ä¸ª
            const sortedConfidences = Object.entries(confidences)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            if (sortedConfidences.length === 0) {
                confidenceChart.innerHTML += '<p style="color: #999;">æœªæ£€æµ‹åˆ°ä»»ä½•å­—æ¯</p>';
            } else {
                sortedConfidences.forEach(([letter, conf]) => {
                    const barDiv = document.createElement('div');
                    barDiv.className = 'confidence-bar';
                    const isSelected = letter === result.letter;
                    barDiv.innerHTML = `
                        <div class="confidence-bar-label" style="${isSelected ? 'color: #4CAF50; font-weight: bold;' : ''}">${letter}</div>
                        <div class="confidence-bar-track">
                            <div class="confidence-bar-fill" style="width: ${conf}%; background: ${isSelected ? '#4CAF50' : '#888'};"></div>
                        </div>
                        <div class="confidence-bar-value">${Math.round(conf)}%</div>
                    `;
                    confidenceChart.appendChild(barDiv);
                });
            }
            
            // æ·»åŠ æ±‡æ€»ä¿¡æ¯
            const summaryDiv = document.createElement('div');
            summaryDiv.className = 'debug-info';
            summaryDiv.innerHTML = `
                <strong>è¯†åˆ«ç»“æœï¼š</strong> ${result.letter || 'æ— '}<br>
                <strong>ç½®ä¿¡åº¦ï¼š</strong> ${result.confidence}%<br>
                <strong>æ ¼å­ä½ç½®ï¼š</strong> [${row}, ${col}]
            `;
            confidenceChart.appendChild(summaryDiv);
        }
        
        function closeDebugPanel() {
            document.getElementById('ocrDebugPanel').classList.remove('active');
        }
        
        function createCellAnalysisUI(analysis, cellData) {
            const div = document.createElement('div');
            div.className = 'cell-analysis';
            
            // æ·»åŠ ç‚¹å‡»äº‹ä»¶
            div.onclick = () => {
                if (analysis.hasLetter) {
                    showDebugPanel(cellData, analysis.row, analysis.col);
                }
            };
            
            // åˆ›å»ºå°ç”»å¸ƒæ˜¾ç¤ºæ ¼å­
            const canvas = document.createElement('canvas');
            canvas.width = 60;
            canvas.height = 60;
            canvas.className = 'cell-preview';
            const ctx = canvas.getContext('2d');
            
            // ç¼©æ”¾å¹¶ç»˜åˆ¶æ ¼å­æ•°æ®åˆ°60x60çš„ç”»å¸ƒ
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = cellData.width;
            tempCanvas.height = cellData.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(cellData, 0, 0);
            
            ctx.drawImage(tempCanvas, 0, 0, cellData.width, cellData.height, 0, 0, 60, 60);
            
            div.innerHTML = `
                <div class="cell-header">
                    <div class="cell-info">
                        <div>æ ¼å­ [${analysis.row}, ${analysis.col}]</div>
                        <div style="margin-top: 5px;">
                            <span class="color-box" style="background: rgb(${analysis.avgColor.r}, ${analysis.avgColor.g}, ${analysis.avgColor.b})"></span>
                            <span style="font-size: 12px;">RGB(${analysis.avgColor.r}, ${analysis.avgColor.g}, ${analysis.avgColor.b})</span>
                        </div>
                        <div style="margin-top: 5px;">
                            <span class="state-badge state-${analysis.state}">${analysis.state.toUpperCase()}</span>
                            ${analysis.hasLetter ? '<span style="margin-left: 5px; color: green;">âœ“ æœ‰å­—æ¯</span>' : '<span style="margin-left: 5px; color: #999;">âœ— æ— å­—æ¯</span>'}
                        </div>
                        ${analysis.letter ? `
                        <div style="margin-top: 5px; background: #e3f2fd; padding: 5px; border-radius: 3px;">
                            <strong style="font-size: 18px; color: #1976d2;">${analysis.letter}</strong>
                            <span style="margin-left: 10px; font-size: 12px; color: #666;">ç½®ä¿¡åº¦: ${analysis.confidence}%</span>
                        </div>
                        ` : ''}
                        ${analysis.hasLetter ? '<div style="margin-top: 5px; font-size: 11px; color: #1976d2;">ğŸ” ç‚¹å‡»æŸ¥çœ‹OCRè°ƒè¯•ä¿¡æ¯</div>' : ''}
                    </div>
                </div>
            `;
            
            div.insertBefore(canvas, div.firstChild);
            
            return div;
        }
        
        function displayGameState(gameRows, container) {
            // æ¸…ç©ºå®¹å™¨
            container.innerHTML = '';
            
            // ç»Ÿè®¡ä¿¡æ¯
            let totalCells = 0;
            let recognizedLetters = 0;
            let totalConfidence = 0;
            let letterCounts = {};
            
            // åˆ›å»ºæ¸¸æˆæ¿æ˜¾ç¤º
            const boardDiv = document.createElement('div');
            boardDiv.className = 'game-board';
            
            gameRows.forEach(row => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'wordle-row';
                
                row.forEach(cell => {
                    totalCells++;
                    const cellDiv = document.createElement('div');
                    cellDiv.className = `wordle-cell ${cell.state !== 'empty' ? cell.state : ''}`;
                    
                    if (cell.letter) {
                        cellDiv.textContent = cell.letter;
                        recognizedLetters++;
                        totalConfidence += cell.confidence;
                        letterCounts[cell.letter] = (letterCounts[cell.letter] || 0) + 1;
                        
                        // æ·»åŠ ç½®ä¿¡åº¦æ ‡ç­¾
                        if (cell.confidence > 0) {
                            const badge = document.createElement('span');
                            badge.className = 'confidence-badge';
                            badge.textContent = `${cell.confidence}%`;
                            cellDiv.appendChild(badge);
                        }
                    } else if (cell.hasLetter) {
                        cellDiv.textContent = '?';
                    }
                    
                    rowDiv.appendChild(cellDiv);
                });
                
                boardDiv.appendChild(rowDiv);
            });
            
            container.appendChild(boardDiv);
            
            // æ·»åŠ è¯†åˆ«ç»Ÿè®¡æ‘˜è¦
            const summaryDiv = document.createElement('div');
            summaryDiv.className = 'recognition-summary';
            
            const avgConfidence = recognizedLetters > 0 ? Math.round(totalConfidence / recognizedLetters) : 0;
            const recognitionRate = totalCells > 0 ? Math.round((recognizedLetters / totalCells) * 100) : 0;
            
            // æ‰¾å‡ºè¯†åˆ«åˆ°çš„å•è¯
            const recognizedWords = [];
            gameRows.forEach(row => {
                const word = row.map(cell => cell.letter || '_').join('');
                if (word.indexOf('_') === -1 && word.length > 0) {
                    recognizedWords.push(word);
                }
            });
            
            summaryDiv.innerHTML = `
                <h3>ğŸ“Š è¯†åˆ«ç»Ÿè®¡</h3>
                <div class="summary-stats">
                    <div class="stat-card">
                        <div class="stat-value">${recognizedLetters}/${totalCells}</div>
                        <div class="stat-label">è¯†åˆ«å­—æ¯æ•°</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${avgConfidence}%</div>
                        <div class="stat-label">å¹³å‡ç½®ä¿¡åº¦</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${recognitionRate}%</div>
                        <div class="stat-label">è¯†åˆ«ç‡</div>
                    </div>
                </div>
                ${recognizedWords.length > 0 ? `
                <div style="margin-top: 15px;">
                    <strong>è¯†åˆ«åˆ°çš„å®Œæ•´å•è¯ï¼š</strong>
                    <div style="margin-top: 5px;">
                        ${recognizedWords.map(word => `
                            <span style="display: inline-block; padding: 5px 10px; margin: 3px; background: #4CAF50; color: white; border-radius: 4px; font-weight: bold;">
                                ${word}
                            </span>
                        `).join('')}
                    </div>
                </div>
                ` : ''}
                ${Object.keys(letterCounts).length > 0 ? `
                <div style="margin-top: 15px;">
                    <strong>å­—æ¯åˆ†å¸ƒï¼š</strong>
                    <div style="margin-top: 5px; font-family: monospace;">
                        ${Object.entries(letterCounts)
                            .sort(([a], [b]) => a.localeCompare(b))
                            .map(([letter, count]) => `${letter}:${count}`)
                            .join(' | ')}
                    </div>
                </div>
                ` : ''}
            `;
            
            container.appendChild(summaryDiv);
        }
    </script>
</body>
</html>