<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>OCRå‚æ•°ä¼˜åŒ–æµ‹è¯•</title>
    <script src='https://unpkg.com/tesseract.js@4.1.1/dist/tesseract.min.js'></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        .test-case {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            background: #f9f9f9;
        }
        .test-case h3 {
            margin: 0 0 10px 0;
            color: #555;
            font-size: 14px;
        }
        canvas {
            border: 1px solid #ccc;
            display: block;
            margin: 10px auto;
            background: white;
        }
        .result {
            margin-top: 10px;
            padding: 10px;
            background: white;
            border-radius: 4px;
            font-size: 14px;
        }
        .result.high-confidence {
            border-left: 4px solid #4CAF50;
        }
        .result.medium-confidence {
            border-left: 4px solid #FFC107;
        }
        .result.low-confidence {
            border-left: 4px solid #f44336;
        }
        .summary {
            margin-top: 30px;
            padding: 20px;
            background: #e7f3ff;
            border-radius: 4px;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 20px auto;
            display: block;
        }
        button:hover {
            background: #45a049;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”¬ Tesseract.js OCRå‚æ•°ä¼˜åŒ–æµ‹è¯•</h1>
        <p style="text-align: center; color: #666;">æµ‹è¯•ä¸åŒOCRå‚æ•°é…ç½®å¯¹å­—æ¯è¯†åˆ«å‡†ç¡®ç‡çš„å½±å“</p>
        
        <button onclick="runTests()">è¿è¡ŒOCRæµ‹è¯•</button>
        
        <div id="testGrid" class="test-grid"></div>
        <div id="summary" class="summary" style="display: none;"></div>
    </div>

    <script>
        // ç”Ÿæˆæµ‹è¯•å­—æ¯
        const testLetters = ['A', 'B', 'E', 'I', 'L', 'O', 'T', 'R', 'S', 'W'];
        
        // ä¸åŒçš„OCRé…ç½®
        const ocrConfigs = [
            {
                name: 'ä¼˜åŒ–é…ç½®ï¼ˆPSM_SINGLE_CHARï¼‰',
                config: {
                    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
                    tessedit_pageseg_mode: '10', // PSM_SINGLE_CHAR
                    tessedit_ocr_engine_mode: '3', // DEFAULT
                    classify_bln_numeric_mode: '0',
                    tessedit_single_match: '0',
                }
            },
            {
                name: 'åŸé…ç½®ï¼ˆPSM_SINGLE_WORDï¼‰',
                config: {
                    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
                    tessedit_pageseg_mode: '8', // PSM_SINGLE_WORD
                    tessedit_ocr_engine_mode: '1', // LSTM only
                    classify_bln_numeric_mode: '0',
                    textord_min_linesize: '2.5',
                }
            },
            {
                name: 'PSM_RAW_LINEæ¨¡å¼',
                config: {
                    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
                    tessedit_pageseg_mode: '13', // PSM_RAW_LINE
                    tessedit_ocr_engine_mode: '3',
                    classify_bln_numeric_mode: '0',
                }
            },
            {
                name: 'æœ€ç®€é…ç½®',
                config: {
                    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
                    tessedit_pageseg_mode: '10', // PSM_SINGLE_CHAR
                }
            }
        ];
        
        // åˆ›å»ºæµ‹è¯•å­—æ¯å›¾åƒ
        function createLetterImage(letter, size = 60) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // ç™½è‰²èƒŒæ™¯
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, size, size);
            
            // é»‘è‰²å­—æ¯
            ctx.fillStyle = 'black';
            ctx.font = `bold ${size * 0.7}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(letter, size / 2, size / 2);
            
            return canvas;
        }
        
        // è¿è¡ŒOCRæµ‹è¯•
        async function testOCR(canvas, config, configName) {
            try {
                const result = await Tesseract.recognize(
                    canvas,
                    'eng',
                    Object.assign({ logger: m => {} }, config)
                );
                
                const text = result.data.text.trim().toUpperCase().replace(/[^A-Z]/g, '');
                const confidence = result.data.confidence || 0;
                
                return {
                    recognized: text.charAt(0) || '?',
                    confidence: Math.round(confidence),
                    configName: configName
                };
            } catch (error) {
                console.error('OCRé”™è¯¯:', error);
                return {
                    recognized: '?',
                    confidence: 0,
                    configName: configName,
                    error: error.message
                };
            }
        }
        
        // è¿è¡Œæ‰€æœ‰æµ‹è¯•
        async function runTests() {
            const gridDiv = document.getElementById('testGrid');
            const summaryDiv = document.getElementById('summary');
            gridDiv.innerHTML = '<p style="text-align: center; grid-column: 1/-1;">â³ æ­£åœ¨è¿è¡ŒOCRæµ‹è¯•ï¼Œè¯·ç¨å€™...</p>';
            
            const results = [];
            const testCases = [];
            
            // ä¸ºæ¯ä¸ªå­—æ¯å’Œæ¯ä¸ªé…ç½®åˆ›å»ºæµ‹è¯•
            for (const letter of testLetters) {
                const letterCanvas = createLetterImage(letter);
                
                for (const configSet of ocrConfigs) {
                    testCases.push({
                        letter: letter,
                        canvas: letterCanvas,
                        config: configSet.config,
                        configName: configSet.name
                    });
                }
            }
            
            // æ‰¹é‡è¿è¡Œæµ‹è¯•
            gridDiv.innerHTML = '';
            
            for (let i = 0; i < testCases.length; i += 4) {
                // æ¯æ¬¡å¹¶è¡Œè¿è¡Œ4ä¸ªæµ‹è¯•
                const batch = testCases.slice(i, i + 4);
                const batchResults = await Promise.all(
                    batch.map(test => testOCR(test.canvas, test.config, test.configName))
                );
                
                // æ˜¾ç¤ºç»“æœ
                batch.forEach((test, index) => {
                    const result = batchResults[index];
                    const isCorrect = result.recognized === test.letter;
                    
                    results.push({
                        ...result,
                        letter: test.letter,
                        correct: isCorrect
                    });
                    
                    // åˆ›å»ºç»“æœæ˜¾ç¤º
                    const testDiv = document.createElement('div');
                    testDiv.className = 'test-case';
                    
                    const confidenceClass = result.confidence > 85 ? 'high-confidence' : 
                                           result.confidence > 70 ? 'medium-confidence' : 
                                           'low-confidence';
                    
                    testDiv.innerHTML = `
                        <h3>${test.configName}</h3>
                        ${test.canvas.outerHTML}
                        <div class="result ${confidenceClass}">
                            <strong>ç›®æ ‡å­—æ¯:</strong> ${test.letter}<br>
                            <strong>è¯†åˆ«ç»“æœ:</strong> ${result.recognized} 
                            ${isCorrect ? 'âœ…' : 'âŒ'}<br>
                            <strong>ç½®ä¿¡åº¦:</strong> ${result.confidence}%
                        </div>
                    `;
                    
                    gridDiv.appendChild(testDiv);
                });
            }
            
            // ç”Ÿæˆç»Ÿè®¡æ‘˜è¦
            const configStats = {};
            ocrConfigs.forEach(config => {
                configStats[config.name] = {
                    correct: 0,
                    total: 0,
                    totalConfidence: 0
                };
            });
            
            results.forEach(result => {
                const stats = configStats[result.configName];
                stats.total++;
                if (result.correct) stats.correct++;
                stats.totalConfidence += result.confidence;
            });
            
            let summaryHTML = '<h2>ğŸ“Š æµ‹è¯•ç»“æœæ±‡æ€»</h2>';
            summaryHTML += '<table style="width: 100%; border-collapse: collapse;">';
            summaryHTML += '<tr style="background: #f0f0f0;"><th style="padding: 10px; text-align: left;">é…ç½®åç§°</th><th>å‡†ç¡®ç‡</th><th>å¹³å‡ç½®ä¿¡åº¦</th></tr>';
            
            let bestConfig = null;
            let bestAccuracy = 0;
            
            for (const [name, stats] of Object.entries(configStats)) {
                const accuracy = (stats.correct / stats.total * 100).toFixed(1);
                const avgConfidence = (stats.totalConfidence / stats.total).toFixed(1);
                
                if (parseFloat(accuracy) > bestAccuracy) {
                    bestAccuracy = parseFloat(accuracy);
                    bestConfig = name;
                }
                
                const isBest = name === bestConfig;
                summaryHTML += `
                    <tr style="${isBest ? 'background: #e8f5e9; font-weight: bold;' : ''}">
                        <td style="padding: 10px;">${name} ${isBest ? 'ğŸ‘‘' : ''}</td>
                        <td>${accuracy}% (${stats.correct}/${stats.total})</td>
                        <td>${avgConfidence}%</td>
                    </tr>
                `;
            }
            
            summaryHTML += '</table>';
            summaryHTML += `<p style="margin-top: 20px;"><strong>ğŸ† æœ€ä½³é…ç½®ï¼š</strong>${bestConfig}ï¼ˆå‡†ç¡®ç‡ ${bestAccuracy}%ï¼‰</p>`;
            
            // é—®é¢˜å­—æ¯åˆ†æ
            const problemLetters = {};
            results.forEach(result => {
                if (!result.correct) {
                    if (!problemLetters[result.letter]) {
                        problemLetters[result.letter] = [];
                    }
                    problemLetters[result.letter].push(result.configName);
                }
            });
            
            if (Object.keys(problemLetters).length > 0) {
                summaryHTML += '<h3>âš ï¸ è¯†åˆ«å›°éš¾çš„å­—æ¯</h3>';
                summaryHTML += '<ul>';
                for (const [letter, configs] of Object.entries(problemLetters)) {
                    summaryHTML += `<li><strong>${letter}</strong>: åœ¨ä»¥ä¸‹é…ç½®ä¸­å¤±è´¥ - ${configs.join(', ')}</li>`;
                }
                summaryHTML += '</ul>';
            }
            
            summaryDiv.innerHTML = summaryHTML;
            summaryDiv.style.display = 'block';
        }
    </script>
</body>
</html>