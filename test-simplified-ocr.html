<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>ç®€åŒ–OCRæµ‹è¯• - æœ€é«˜ç½®ä¿¡åº¦é€‰æ‹©</title>
    <script src='https://unpkg.com/tesseract.js@4.1.1/dist/tesseract.min.js'></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        .info-box h3 {
            margin: 0 0 10px 0;
            color: #1976D2;
        }
        .info-box ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        .test-case {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            text-align: center;
            background: #f9f9f9;
        }
        canvas {
            border: 1px solid #ccc;
            display: block;
            margin: 10px auto;
            background: white;
        }
        .result {
            margin-top: 10px;
            padding: 8px;
            background: white;
            border-radius: 4px;
            font-size: 14px;
        }
        .candidates {
            margin-top: 10px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 4px;
            font-size: 12px;
        }
        .candidate {
            display: inline-block;
            margin: 2px;
            padding: 3px 8px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        .candidate.selected {
            background: #4CAF50;
            color: white;
            border-color: #4CAF50;
            font-weight: bold;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 20px auto;
            display: block;
        }
        button:hover {
            background: #45a049;
        }
        .success { color: #4CAF50; font-weight: bold; }
        .failure { color: #f44336; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¯ ç®€åŒ–OCRæµ‹è¯• - æœ€é«˜ç½®ä¿¡åº¦é€‰æ‹©</h1>
        
        <div class="info-box">
            <h3>ğŸ“‹ ä¼˜åŒ–ç­–ç•¥</h3>
            <ul>
                <li>âœ… é¢„å¤„ç†ï¼šç™½åº•é»‘å­—æ ‡å‡†åŒ–</li>
                <li>âœ… ä»æ‰€æœ‰å€™é€‰å­—æ¯ä¸­é€‰æ‹©ç½®ä¿¡åº¦æœ€é«˜çš„</li>
                <li>âŒ ä¸å†ä½¿ç”¨å¢å¼ºå¯¹æ¯”åº¦ï¼ˆå·²ç§»é™¤ï¼‰</li>
                <li>âœ… å¦‚æœç¬¬ä¸€æ¬¡å¤±è´¥ï¼Œå°è¯•ä¸åŒçš„PSMæ¨¡å¼</li>
            </ul>
        </div>
        
        <button onclick="runTest()">è¿è¡Œæµ‹è¯•</button>
        
        <div id="testGrid" class="test-grid"></div>
    </div>

    <script>
        const testLetters = ['A', 'E', 'I', 'O', 'T', 'L', 'R', 'S', 'N', 'B'];
        
        // åˆ›å»ºæµ‹è¯•å­—æ¯å›¾åƒï¼ˆç™½åº•é»‘å­—ï¼‰
        function createLetterImage(letter, size = 60) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // ç™½è‰²èƒŒæ™¯
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, size, size);
            
            // é»‘è‰²å­—æ¯
            ctx.fillStyle = 'black';
            ctx.font = `bold ${size * 0.7}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(letter, size / 2, size / 2);
            
            return canvas;
        }
        
        // ç®€åŒ–çš„OCRè¯†åˆ«ï¼ˆæ¨¡æ‹Ÿä¸»ä»£ç é€»è¾‘ï¼‰
        async function recognizeWithHighestConfidence(canvas, targetLetter) {
            try {
                // ç¬¬ä¸€æ¬¡è¯†åˆ«ï¼šPSM_SINGLE_CHAR
                const result = await Tesseract.recognize(
                    canvas,
                    'eng',
                    {
                        logger: m => {},
                        tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
                        tessedit_pageseg_mode: '10', // PSM_SINGLE_CHAR
                        tessedit_ocr_engine_mode: '3', // DEFAULT
                        classify_bln_numeric_mode: '0',
                        tessedit_single_match: '0',
                    }
                );
                
                // æ”¶é›†æ‰€æœ‰å€™é€‰å­—æ¯åŠå…¶ç½®ä¿¡åº¦
                const candidates = {};
                let bestLetter = '';
                let bestConfidence = 0;
                
                if (result.data.symbols && result.data.symbols.length > 0) {
                    result.data.symbols.forEach(symbol => {
                        const cleanText = symbol.text.trim().toUpperCase();
                        if (/^[A-Z]$/.test(cleanText)) {
                            candidates[cleanText] = Math.max(
                                candidates[cleanText] || 0,
                                symbol.confidence
                            );
                            
                            if (symbol.confidence > bestConfidence) {
                                bestLetter = cleanText;
                                bestConfidence = symbol.confidence;
                            }
                        }
                    });
                }
                
                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å­—æ¯ï¼Œå°è¯•PSM_RAW_LINEæ¨¡å¼
                if (!bestLetter) {
                    const result2 = await Tesseract.recognize(
                        canvas,
                        'eng',
                        {
                            logger: m => {},
                            tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
                            tessedit_pageseg_mode: '13', // PSM_RAW_LINE
                            tessedit_ocr_engine_mode: '3',
                        }
                    );
                    
                    if (result2.data.symbols && result2.data.symbols.length > 0) {
                        result2.data.symbols.forEach(symbol => {
                            const cleanText = symbol.text.trim().toUpperCase();
                            if (/^[A-Z]$/.test(cleanText)) {
                                candidates[cleanText] = Math.max(
                                    candidates[cleanText] || 0,
                                    symbol.confidence
                                );
                                
                                if (symbol.confidence > bestConfidence) {
                                    bestLetter = cleanText;
                                    bestConfidence = symbol.confidence;
                                }
                            }
                        });
                    }
                }
                
                return {
                    recognized: bestLetter || '?',
                    confidence: Math.round(bestConfidence),
                    candidates: candidates,
                    correct: bestLetter === targetLetter
                };
                
            } catch (error) {
                console.error('OCRé”™è¯¯:', error);
                return {
                    recognized: '?',
                    confidence: 0,
                    candidates: {},
                    correct: false,
                    error: error.message
                };
            }
        }
        
        // è¿è¡Œæµ‹è¯•
        async function runTest() {
            const gridDiv = document.getElementById('testGrid');
            gridDiv.innerHTML = '<p style="grid-column: 1/-1; text-align: center;">â³ æ­£åœ¨æµ‹è¯•ï¼Œè¯·ç¨å€™...</p>';
            
            const results = [];
            
            for (const letter of testLetters) {
                const canvas = createLetterImage(letter);
                const result = await recognizeWithHighestConfidence(canvas, letter);
                results.push({ letter, ...result });
                
                // åˆ›å»ºç»“æœæ˜¾ç¤º
                const testDiv = document.createElement('div');
                testDiv.className = 'test-case';
                
                // ç”Ÿæˆå€™é€‰åˆ—è¡¨HTML
                let candidatesHTML = '';
                if (Object.keys(result.candidates).length > 0) {
                    const sortedCandidates = Object.entries(result.candidates)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 5); // æ˜¾ç¤ºå‰5ä¸ªå€™é€‰
                    
                    candidatesHTML = '<div class="candidates"><strong>å€™é€‰å­—æ¯ï¼š</strong><br>';
                    sortedCandidates.forEach(([char, conf]) => {
                        const isSelected = char === result.recognized;
                        candidatesHTML += `<span class="candidate ${isSelected ? 'selected' : ''}">${char}: ${Math.round(conf)}%</span>`;
                    });
                    candidatesHTML += '</div>';
                }
                
                testDiv.innerHTML = `
                    <h4>ç›®æ ‡: ${letter}</h4>
                    ${canvas.outerHTML}
                    <div class="result">
                        <div class="${result.correct ? 'success' : 'failure'}">
                            è¯†åˆ«: ${result.recognized} ${result.correct ? 'âœ…' : 'âŒ'}
                        </div>
                        <div>ç½®ä¿¡åº¦: ${result.confidence}%</div>
                    </div>
                    ${candidatesHTML}
                `;
                
                gridDiv.appendChild(testDiv);
            }
            
            // è®¡ç®—ç»Ÿè®¡
            const correctCount = results.filter(r => r.correct).length;
            const accuracy = (correctCount / results.length * 100).toFixed(1);
            const avgConfidence = (results.reduce((sum, r) => sum + r.confidence, 0) / results.length).toFixed(1);
            
            // æ˜¾ç¤ºæ€»ç»“
            const summaryDiv = document.createElement('div');
            summaryDiv.style.gridColumn = '1/-1';
            summaryDiv.className = 'info-box';
            summaryDiv.style.marginTop = '20px';
            summaryDiv.innerHTML = `
                <h3>ğŸ“Š æµ‹è¯•ç»“æœ</h3>
                <ul>
                    <li>å‡†ç¡®ç‡: <strong>${accuracy}%</strong> (${correctCount}/${results.length})</li>
                    <li>å¹³å‡ç½®ä¿¡åº¦: <strong>${avgConfidence}%</strong></li>
                    <li>è¯†åˆ«ç­–ç•¥: é€‰æ‹©æ‰€æœ‰å€™é€‰ä¸­ç½®ä¿¡åº¦æœ€é«˜çš„å­—æ¯</li>
                </ul>
                ${accuracy >= 90 ? '<p style="color: #4CAF50;">âœ… è¯†åˆ«æ•ˆæœè‰¯å¥½ï¼</p>' : 
                  accuracy >= 70 ? '<p style="color: #FFC107;">âš ï¸ è¯†åˆ«æ•ˆæœä¸€èˆ¬ï¼Œå¯èƒ½éœ€è¦è¿›ä¸€æ­¥ä¼˜åŒ–</p>' :
                  '<p style="color: #f44336;">âŒ è¯†åˆ«æ•ˆæœè¾ƒå·®ï¼Œå»ºè®®æ£€æŸ¥é¢„å¤„ç†</p>'}
            `;
            
            gridDiv.appendChild(summaryDiv);
        }
    </script>
</body>
</html>